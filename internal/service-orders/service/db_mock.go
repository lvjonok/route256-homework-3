package service

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/lvjonok/homework-3/internal/service-orders/service.DB -o ./db_mock.go -n DBMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	types "gitlab.ozon.dev/lvjonok/homework-3/core/models"
	"gitlab.ozon.dev/lvjonok/homework-3/internal/service-orders/models"
)

// DBMock implements DB
type DBMock struct {
	t minimock.Tester

	funcAddRetry          func(ctx context.Context, order_id types.ID, saga models.OrderStatus) (err error)
	inspectFuncAddRetry   func(ctx context.Context, order_id types.ID, saga models.OrderStatus)
	afterAddRetryCounter  uint64
	beforeAddRetryCounter uint64
	AddRetryMock          mDBMockAddRetry

	funcCheckStatus          func(ctx context.Context, ip1 *types.ID) (s1 string, err error)
	inspectFuncCheckStatus   func(ctx context.Context, ip1 *types.ID)
	afterCheckStatusCounter  uint64
	beforeCheckStatusCounter uint64
	CheckStatusMock          mDBMockCheckStatus

	funcCreateOrder          func(ctx context.Context, op1 *models.Order) (ip1 *types.ID, err error)
	inspectFuncCreateOrder   func(ctx context.Context, op1 *models.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mDBMockCreateOrder

	funcGetOrder          func(ctx context.Context, ip1 *types.ID) (op1 *models.Order, err error)
	inspectFuncGetOrder   func(ctx context.Context, ip1 *types.ID)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mDBMockGetOrder

	funcGetProcessingOrders          func(ctx context.Context, retries int) (ia1 []types.ID, err error)
	inspectFuncGetProcessingOrders   func(ctx context.Context, retries int)
	afterGetProcessingOrdersCounter  uint64
	beforeGetProcessingOrdersCounter uint64
	GetProcessingOrdersMock          mDBMockGetProcessingOrders

	funcUpdateOrderSagaStatus          func(ctx context.Context, order *models.Order) (err error)
	inspectFuncUpdateOrderSagaStatus   func(ctx context.Context, order *models.Order)
	afterUpdateOrderSagaStatusCounter  uint64
	beforeUpdateOrderSagaStatusCounter uint64
	UpdateOrderSagaStatusMock          mDBMockUpdateOrderSagaStatus

	funcUpdateStatus          func(ctx context.Context, op1 *models.Order) (err error)
	inspectFuncUpdateStatus   func(ctx context.Context, op1 *models.Order)
	afterUpdateStatusCounter  uint64
	beforeUpdateStatusCounter uint64
	UpdateStatusMock          mDBMockUpdateStatus
}

// NewDBMock returns a mock for DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddRetryMock = mDBMockAddRetry{mock: m}
	m.AddRetryMock.callArgs = []*DBMockAddRetryParams{}

	m.CheckStatusMock = mDBMockCheckStatus{mock: m}
	m.CheckStatusMock.callArgs = []*DBMockCheckStatusParams{}

	m.CreateOrderMock = mDBMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*DBMockCreateOrderParams{}

	m.GetOrderMock = mDBMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*DBMockGetOrderParams{}

	m.GetProcessingOrdersMock = mDBMockGetProcessingOrders{mock: m}
	m.GetProcessingOrdersMock.callArgs = []*DBMockGetProcessingOrdersParams{}

	m.UpdateOrderSagaStatusMock = mDBMockUpdateOrderSagaStatus{mock: m}
	m.UpdateOrderSagaStatusMock.callArgs = []*DBMockUpdateOrderSagaStatusParams{}

	m.UpdateStatusMock = mDBMockUpdateStatus{mock: m}
	m.UpdateStatusMock.callArgs = []*DBMockUpdateStatusParams{}

	return m
}

type mDBMockAddRetry struct {
	mock               *DBMock
	defaultExpectation *DBMockAddRetryExpectation
	expectations       []*DBMockAddRetryExpectation

	callArgs []*DBMockAddRetryParams
	mutex    sync.RWMutex
}

// DBMockAddRetryExpectation specifies expectation struct of the DB.AddRetry
type DBMockAddRetryExpectation struct {
	mock    *DBMock
	params  *DBMockAddRetryParams
	results *DBMockAddRetryResults
	Counter uint64
}

// DBMockAddRetryParams contains parameters of the DB.AddRetry
type DBMockAddRetryParams struct {
	ctx      context.Context
	order_id types.ID
	saga     models.OrderStatus
}

// DBMockAddRetryResults contains results of the DB.AddRetry
type DBMockAddRetryResults struct {
	err error
}

// Expect sets up expected params for DB.AddRetry
func (mmAddRetry *mDBMockAddRetry) Expect(ctx context.Context, order_id types.ID, saga models.OrderStatus) *mDBMockAddRetry {
	if mmAddRetry.mock.funcAddRetry != nil {
		mmAddRetry.mock.t.Fatalf("DBMock.AddRetry mock is already set by Set")
	}

	if mmAddRetry.defaultExpectation == nil {
		mmAddRetry.defaultExpectation = &DBMockAddRetryExpectation{}
	}

	mmAddRetry.defaultExpectation.params = &DBMockAddRetryParams{ctx, order_id, saga}
	for _, e := range mmAddRetry.expectations {
		if minimock.Equal(e.params, mmAddRetry.defaultExpectation.params) {
			mmAddRetry.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRetry.defaultExpectation.params)
		}
	}

	return mmAddRetry
}

// Inspect accepts an inspector function that has same arguments as the DB.AddRetry
func (mmAddRetry *mDBMockAddRetry) Inspect(f func(ctx context.Context, order_id types.ID, saga models.OrderStatus)) *mDBMockAddRetry {
	if mmAddRetry.mock.inspectFuncAddRetry != nil {
		mmAddRetry.mock.t.Fatalf("Inspect function is already set for DBMock.AddRetry")
	}

	mmAddRetry.mock.inspectFuncAddRetry = f

	return mmAddRetry
}

// Return sets up results that will be returned by DB.AddRetry
func (mmAddRetry *mDBMockAddRetry) Return(err error) *DBMock {
	if mmAddRetry.mock.funcAddRetry != nil {
		mmAddRetry.mock.t.Fatalf("DBMock.AddRetry mock is already set by Set")
	}

	if mmAddRetry.defaultExpectation == nil {
		mmAddRetry.defaultExpectation = &DBMockAddRetryExpectation{mock: mmAddRetry.mock}
	}
	mmAddRetry.defaultExpectation.results = &DBMockAddRetryResults{err}
	return mmAddRetry.mock
}

//Set uses given function f to mock the DB.AddRetry method
func (mmAddRetry *mDBMockAddRetry) Set(f func(ctx context.Context, order_id types.ID, saga models.OrderStatus) (err error)) *DBMock {
	if mmAddRetry.defaultExpectation != nil {
		mmAddRetry.mock.t.Fatalf("Default expectation is already set for the DB.AddRetry method")
	}

	if len(mmAddRetry.expectations) > 0 {
		mmAddRetry.mock.t.Fatalf("Some expectations are already set for the DB.AddRetry method")
	}

	mmAddRetry.mock.funcAddRetry = f
	return mmAddRetry.mock
}

// When sets expectation for the DB.AddRetry which will trigger the result defined by the following
// Then helper
func (mmAddRetry *mDBMockAddRetry) When(ctx context.Context, order_id types.ID, saga models.OrderStatus) *DBMockAddRetryExpectation {
	if mmAddRetry.mock.funcAddRetry != nil {
		mmAddRetry.mock.t.Fatalf("DBMock.AddRetry mock is already set by Set")
	}

	expectation := &DBMockAddRetryExpectation{
		mock:   mmAddRetry.mock,
		params: &DBMockAddRetryParams{ctx, order_id, saga},
	}
	mmAddRetry.expectations = append(mmAddRetry.expectations, expectation)
	return expectation
}

// Then sets up DB.AddRetry return parameters for the expectation previously defined by the When method
func (e *DBMockAddRetryExpectation) Then(err error) *DBMock {
	e.results = &DBMockAddRetryResults{err}
	return e.mock
}

// AddRetry implements DB
func (mmAddRetry *DBMock) AddRetry(ctx context.Context, order_id types.ID, saga models.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmAddRetry.beforeAddRetryCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRetry.afterAddRetryCounter, 1)

	if mmAddRetry.inspectFuncAddRetry != nil {
		mmAddRetry.inspectFuncAddRetry(ctx, order_id, saga)
	}

	mm_params := &DBMockAddRetryParams{ctx, order_id, saga}

	// Record call args
	mmAddRetry.AddRetryMock.mutex.Lock()
	mmAddRetry.AddRetryMock.callArgs = append(mmAddRetry.AddRetryMock.callArgs, mm_params)
	mmAddRetry.AddRetryMock.mutex.Unlock()

	for _, e := range mmAddRetry.AddRetryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddRetry.AddRetryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRetry.AddRetryMock.defaultExpectation.Counter, 1)
		mm_want := mmAddRetry.AddRetryMock.defaultExpectation.params
		mm_got := DBMockAddRetryParams{ctx, order_id, saga}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddRetry.t.Errorf("DBMock.AddRetry got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddRetry.AddRetryMock.defaultExpectation.results
		if mm_results == nil {
			mmAddRetry.t.Fatal("No results are set for the DBMock.AddRetry")
		}
		return (*mm_results).err
	}
	if mmAddRetry.funcAddRetry != nil {
		return mmAddRetry.funcAddRetry(ctx, order_id, saga)
	}
	mmAddRetry.t.Fatalf("Unexpected call to DBMock.AddRetry. %v %v %v", ctx, order_id, saga)
	return
}

// AddRetryAfterCounter returns a count of finished DBMock.AddRetry invocations
func (mmAddRetry *DBMock) AddRetryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRetry.afterAddRetryCounter)
}

// AddRetryBeforeCounter returns a count of DBMock.AddRetry invocations
func (mmAddRetry *DBMock) AddRetryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRetry.beforeAddRetryCounter)
}

// Calls returns a list of arguments used in each call to DBMock.AddRetry.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRetry *mDBMockAddRetry) Calls() []*DBMockAddRetryParams {
	mmAddRetry.mutex.RLock()

	argCopy := make([]*DBMockAddRetryParams, len(mmAddRetry.callArgs))
	copy(argCopy, mmAddRetry.callArgs)

	mmAddRetry.mutex.RUnlock()

	return argCopy
}

// MinimockAddRetryDone returns true if the count of the AddRetry invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockAddRetryDone() bool {
	for _, e := range m.AddRetryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRetryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRetryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRetry != nil && mm_atomic.LoadUint64(&m.afterAddRetryCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddRetryInspect logs each unmet expectation
func (m *DBMock) MinimockAddRetryInspect() {
	for _, e := range m.AddRetryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.AddRetry with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRetryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRetryCounter) < 1 {
		if m.AddRetryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.AddRetry")
		} else {
			m.t.Errorf("Expected call to DBMock.AddRetry with params: %#v", *m.AddRetryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRetry != nil && mm_atomic.LoadUint64(&m.afterAddRetryCounter) < 1 {
		m.t.Error("Expected call to DBMock.AddRetry")
	}
}

type mDBMockCheckStatus struct {
	mock               *DBMock
	defaultExpectation *DBMockCheckStatusExpectation
	expectations       []*DBMockCheckStatusExpectation

	callArgs []*DBMockCheckStatusParams
	mutex    sync.RWMutex
}

// DBMockCheckStatusExpectation specifies expectation struct of the DB.CheckStatus
type DBMockCheckStatusExpectation struct {
	mock    *DBMock
	params  *DBMockCheckStatusParams
	results *DBMockCheckStatusResults
	Counter uint64
}

// DBMockCheckStatusParams contains parameters of the DB.CheckStatus
type DBMockCheckStatusParams struct {
	ctx context.Context
	ip1 *types.ID
}

// DBMockCheckStatusResults contains results of the DB.CheckStatus
type DBMockCheckStatusResults struct {
	s1  string
	err error
}

// Expect sets up expected params for DB.CheckStatus
func (mmCheckStatus *mDBMockCheckStatus) Expect(ctx context.Context, ip1 *types.ID) *mDBMockCheckStatus {
	if mmCheckStatus.mock.funcCheckStatus != nil {
		mmCheckStatus.mock.t.Fatalf("DBMock.CheckStatus mock is already set by Set")
	}

	if mmCheckStatus.defaultExpectation == nil {
		mmCheckStatus.defaultExpectation = &DBMockCheckStatusExpectation{}
	}

	mmCheckStatus.defaultExpectation.params = &DBMockCheckStatusParams{ctx, ip1}
	for _, e := range mmCheckStatus.expectations {
		if minimock.Equal(e.params, mmCheckStatus.defaultExpectation.params) {
			mmCheckStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckStatus.defaultExpectation.params)
		}
	}

	return mmCheckStatus
}

// Inspect accepts an inspector function that has same arguments as the DB.CheckStatus
func (mmCheckStatus *mDBMockCheckStatus) Inspect(f func(ctx context.Context, ip1 *types.ID)) *mDBMockCheckStatus {
	if mmCheckStatus.mock.inspectFuncCheckStatus != nil {
		mmCheckStatus.mock.t.Fatalf("Inspect function is already set for DBMock.CheckStatus")
	}

	mmCheckStatus.mock.inspectFuncCheckStatus = f

	return mmCheckStatus
}

// Return sets up results that will be returned by DB.CheckStatus
func (mmCheckStatus *mDBMockCheckStatus) Return(s1 string, err error) *DBMock {
	if mmCheckStatus.mock.funcCheckStatus != nil {
		mmCheckStatus.mock.t.Fatalf("DBMock.CheckStatus mock is already set by Set")
	}

	if mmCheckStatus.defaultExpectation == nil {
		mmCheckStatus.defaultExpectation = &DBMockCheckStatusExpectation{mock: mmCheckStatus.mock}
	}
	mmCheckStatus.defaultExpectation.results = &DBMockCheckStatusResults{s1, err}
	return mmCheckStatus.mock
}

//Set uses given function f to mock the DB.CheckStatus method
func (mmCheckStatus *mDBMockCheckStatus) Set(f func(ctx context.Context, ip1 *types.ID) (s1 string, err error)) *DBMock {
	if mmCheckStatus.defaultExpectation != nil {
		mmCheckStatus.mock.t.Fatalf("Default expectation is already set for the DB.CheckStatus method")
	}

	if len(mmCheckStatus.expectations) > 0 {
		mmCheckStatus.mock.t.Fatalf("Some expectations are already set for the DB.CheckStatus method")
	}

	mmCheckStatus.mock.funcCheckStatus = f
	return mmCheckStatus.mock
}

// When sets expectation for the DB.CheckStatus which will trigger the result defined by the following
// Then helper
func (mmCheckStatus *mDBMockCheckStatus) When(ctx context.Context, ip1 *types.ID) *DBMockCheckStatusExpectation {
	if mmCheckStatus.mock.funcCheckStatus != nil {
		mmCheckStatus.mock.t.Fatalf("DBMock.CheckStatus mock is already set by Set")
	}

	expectation := &DBMockCheckStatusExpectation{
		mock:   mmCheckStatus.mock,
		params: &DBMockCheckStatusParams{ctx, ip1},
	}
	mmCheckStatus.expectations = append(mmCheckStatus.expectations, expectation)
	return expectation
}

// Then sets up DB.CheckStatus return parameters for the expectation previously defined by the When method
func (e *DBMockCheckStatusExpectation) Then(s1 string, err error) *DBMock {
	e.results = &DBMockCheckStatusResults{s1, err}
	return e.mock
}

// CheckStatus implements DB
func (mmCheckStatus *DBMock) CheckStatus(ctx context.Context, ip1 *types.ID) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCheckStatus.beforeCheckStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckStatus.afterCheckStatusCounter, 1)

	if mmCheckStatus.inspectFuncCheckStatus != nil {
		mmCheckStatus.inspectFuncCheckStatus(ctx, ip1)
	}

	mm_params := &DBMockCheckStatusParams{ctx, ip1}

	// Record call args
	mmCheckStatus.CheckStatusMock.mutex.Lock()
	mmCheckStatus.CheckStatusMock.callArgs = append(mmCheckStatus.CheckStatusMock.callArgs, mm_params)
	mmCheckStatus.CheckStatusMock.mutex.Unlock()

	for _, e := range mmCheckStatus.CheckStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCheckStatus.CheckStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckStatus.CheckStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckStatus.CheckStatusMock.defaultExpectation.params
		mm_got := DBMockCheckStatusParams{ctx, ip1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckStatus.t.Errorf("DBMock.CheckStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckStatus.CheckStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckStatus.t.Fatal("No results are set for the DBMock.CheckStatus")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCheckStatus.funcCheckStatus != nil {
		return mmCheckStatus.funcCheckStatus(ctx, ip1)
	}
	mmCheckStatus.t.Fatalf("Unexpected call to DBMock.CheckStatus. %v %v", ctx, ip1)
	return
}

// CheckStatusAfterCounter returns a count of finished DBMock.CheckStatus invocations
func (mmCheckStatus *DBMock) CheckStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckStatus.afterCheckStatusCounter)
}

// CheckStatusBeforeCounter returns a count of DBMock.CheckStatus invocations
func (mmCheckStatus *DBMock) CheckStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckStatus.beforeCheckStatusCounter)
}

// Calls returns a list of arguments used in each call to DBMock.CheckStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckStatus *mDBMockCheckStatus) Calls() []*DBMockCheckStatusParams {
	mmCheckStatus.mutex.RLock()

	argCopy := make([]*DBMockCheckStatusParams, len(mmCheckStatus.callArgs))
	copy(argCopy, mmCheckStatus.callArgs)

	mmCheckStatus.mutex.RUnlock()

	return argCopy
}

// MinimockCheckStatusDone returns true if the count of the CheckStatus invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCheckStatusDone() bool {
	for _, e := range m.CheckStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckStatus != nil && mm_atomic.LoadUint64(&m.afterCheckStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckStatusInspect logs each unmet expectation
func (m *DBMock) MinimockCheckStatusInspect() {
	for _, e := range m.CheckStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.CheckStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckStatusCounter) < 1 {
		if m.CheckStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.CheckStatus")
		} else {
			m.t.Errorf("Expected call to DBMock.CheckStatus with params: %#v", *m.CheckStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckStatus != nil && mm_atomic.LoadUint64(&m.afterCheckStatusCounter) < 1 {
		m.t.Error("Expected call to DBMock.CheckStatus")
	}
}

type mDBMockCreateOrder struct {
	mock               *DBMock
	defaultExpectation *DBMockCreateOrderExpectation
	expectations       []*DBMockCreateOrderExpectation

	callArgs []*DBMockCreateOrderParams
	mutex    sync.RWMutex
}

// DBMockCreateOrderExpectation specifies expectation struct of the DB.CreateOrder
type DBMockCreateOrderExpectation struct {
	mock    *DBMock
	params  *DBMockCreateOrderParams
	results *DBMockCreateOrderResults
	Counter uint64
}

// DBMockCreateOrderParams contains parameters of the DB.CreateOrder
type DBMockCreateOrderParams struct {
	ctx context.Context
	op1 *models.Order
}

// DBMockCreateOrderResults contains results of the DB.CreateOrder
type DBMockCreateOrderResults struct {
	ip1 *types.ID
	err error
}

// Expect sets up expected params for DB.CreateOrder
func (mmCreateOrder *mDBMockCreateOrder) Expect(ctx context.Context, op1 *models.Order) *mDBMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("DBMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &DBMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &DBMockCreateOrderParams{ctx, op1}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the DB.CreateOrder
func (mmCreateOrder *mDBMockCreateOrder) Inspect(f func(ctx context.Context, op1 *models.Order)) *mDBMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for DBMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by DB.CreateOrder
func (mmCreateOrder *mDBMockCreateOrder) Return(ip1 *types.ID, err error) *DBMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("DBMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &DBMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &DBMockCreateOrderResults{ip1, err}
	return mmCreateOrder.mock
}

//Set uses given function f to mock the DB.CreateOrder method
func (mmCreateOrder *mDBMockCreateOrder) Set(f func(ctx context.Context, op1 *models.Order) (ip1 *types.ID, err error)) *DBMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the DB.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the DB.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the DB.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mDBMockCreateOrder) When(ctx context.Context, op1 *models.Order) *DBMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("DBMock.CreateOrder mock is already set by Set")
	}

	expectation := &DBMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &DBMockCreateOrderParams{ctx, op1},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up DB.CreateOrder return parameters for the expectation previously defined by the When method
func (e *DBMockCreateOrderExpectation) Then(ip1 *types.ID, err error) *DBMock {
	e.results = &DBMockCreateOrderResults{ip1, err}
	return e.mock
}

// CreateOrder implements DB
func (mmCreateOrder *DBMock) CreateOrder(ctx context.Context, op1 *models.Order) (ip1 *types.ID, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, op1)
	}

	mm_params := &DBMockCreateOrderParams{ctx, op1}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := DBMockCreateOrderParams{ctx, op1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("DBMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the DBMock.CreateOrder")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, op1)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to DBMock.CreateOrder. %v %v", ctx, op1)
	return
}

// CreateOrderAfterCounter returns a count of finished DBMock.CreateOrder invocations
func (mmCreateOrder *DBMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of DBMock.CreateOrder invocations
func (mmCreateOrder *DBMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to DBMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mDBMockCreateOrder) Calls() []*DBMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*DBMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *DBMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to DBMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to DBMock.CreateOrder")
	}
}

type mDBMockGetOrder struct {
	mock               *DBMock
	defaultExpectation *DBMockGetOrderExpectation
	expectations       []*DBMockGetOrderExpectation

	callArgs []*DBMockGetOrderParams
	mutex    sync.RWMutex
}

// DBMockGetOrderExpectation specifies expectation struct of the DB.GetOrder
type DBMockGetOrderExpectation struct {
	mock    *DBMock
	params  *DBMockGetOrderParams
	results *DBMockGetOrderResults
	Counter uint64
}

// DBMockGetOrderParams contains parameters of the DB.GetOrder
type DBMockGetOrderParams struct {
	ctx context.Context
	ip1 *types.ID
}

// DBMockGetOrderResults contains results of the DB.GetOrder
type DBMockGetOrderResults struct {
	op1 *models.Order
	err error
}

// Expect sets up expected params for DB.GetOrder
func (mmGetOrder *mDBMockGetOrder) Expect(ctx context.Context, ip1 *types.ID) *mDBMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("DBMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &DBMockGetOrderExpectation{}
	}

	mmGetOrder.defaultExpectation.params = &DBMockGetOrderParams{ctx, ip1}
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the DB.GetOrder
func (mmGetOrder *mDBMockGetOrder) Inspect(f func(ctx context.Context, ip1 *types.ID)) *mDBMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for DBMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by DB.GetOrder
func (mmGetOrder *mDBMockGetOrder) Return(op1 *models.Order, err error) *DBMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("DBMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &DBMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &DBMockGetOrderResults{op1, err}
	return mmGetOrder.mock
}

//Set uses given function f to mock the DB.GetOrder method
func (mmGetOrder *mDBMockGetOrder) Set(f func(ctx context.Context, ip1 *types.ID) (op1 *models.Order, err error)) *DBMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the DB.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the DB.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	return mmGetOrder.mock
}

// When sets expectation for the DB.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mDBMockGetOrder) When(ctx context.Context, ip1 *types.ID) *DBMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("DBMock.GetOrder mock is already set by Set")
	}

	expectation := &DBMockGetOrderExpectation{
		mock:   mmGetOrder.mock,
		params: &DBMockGetOrderParams{ctx, ip1},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up DB.GetOrder return parameters for the expectation previously defined by the When method
func (e *DBMockGetOrderExpectation) Then(op1 *models.Order, err error) *DBMock {
	e.results = &DBMockGetOrderResults{op1, err}
	return e.mock
}

// GetOrder implements DB
func (mmGetOrder *DBMock) GetOrder(ctx context.Context, ip1 *types.ID) (op1 *models.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(ctx, ip1)
	}

	mm_params := &DBMockGetOrderParams{ctx, ip1}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_got := DBMockGetOrderParams{ctx, ip1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("DBMock.GetOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the DBMock.GetOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(ctx, ip1)
	}
	mmGetOrder.t.Fatalf("Unexpected call to DBMock.GetOrder. %v %v", ctx, ip1)
	return
}

// GetOrderAfterCounter returns a count of finished DBMock.GetOrder invocations
func (mmGetOrder *DBMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of DBMock.GetOrder invocations
func (mmGetOrder *DBMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mDBMockGetOrder) Calls() []*DBMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*DBMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetOrderDone() bool {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *DBMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetOrder")
		} else {
			m.t.Errorf("Expected call to DBMock.GetOrder with params: %#v", *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && mm_atomic.LoadUint64(&m.afterGetOrderCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetOrder")
	}
}

type mDBMockGetProcessingOrders struct {
	mock               *DBMock
	defaultExpectation *DBMockGetProcessingOrdersExpectation
	expectations       []*DBMockGetProcessingOrdersExpectation

	callArgs []*DBMockGetProcessingOrdersParams
	mutex    sync.RWMutex
}

// DBMockGetProcessingOrdersExpectation specifies expectation struct of the DB.GetProcessingOrders
type DBMockGetProcessingOrdersExpectation struct {
	mock    *DBMock
	params  *DBMockGetProcessingOrdersParams
	results *DBMockGetProcessingOrdersResults
	Counter uint64
}

// DBMockGetProcessingOrdersParams contains parameters of the DB.GetProcessingOrders
type DBMockGetProcessingOrdersParams struct {
	ctx     context.Context
	retries int
}

// DBMockGetProcessingOrdersResults contains results of the DB.GetProcessingOrders
type DBMockGetProcessingOrdersResults struct {
	ia1 []types.ID
	err error
}

// Expect sets up expected params for DB.GetProcessingOrders
func (mmGetProcessingOrders *mDBMockGetProcessingOrders) Expect(ctx context.Context, retries int) *mDBMockGetProcessingOrders {
	if mmGetProcessingOrders.mock.funcGetProcessingOrders != nil {
		mmGetProcessingOrders.mock.t.Fatalf("DBMock.GetProcessingOrders mock is already set by Set")
	}

	if mmGetProcessingOrders.defaultExpectation == nil {
		mmGetProcessingOrders.defaultExpectation = &DBMockGetProcessingOrdersExpectation{}
	}

	mmGetProcessingOrders.defaultExpectation.params = &DBMockGetProcessingOrdersParams{ctx, retries}
	for _, e := range mmGetProcessingOrders.expectations {
		if minimock.Equal(e.params, mmGetProcessingOrders.defaultExpectation.params) {
			mmGetProcessingOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProcessingOrders.defaultExpectation.params)
		}
	}

	return mmGetProcessingOrders
}

// Inspect accepts an inspector function that has same arguments as the DB.GetProcessingOrders
func (mmGetProcessingOrders *mDBMockGetProcessingOrders) Inspect(f func(ctx context.Context, retries int)) *mDBMockGetProcessingOrders {
	if mmGetProcessingOrders.mock.inspectFuncGetProcessingOrders != nil {
		mmGetProcessingOrders.mock.t.Fatalf("Inspect function is already set for DBMock.GetProcessingOrders")
	}

	mmGetProcessingOrders.mock.inspectFuncGetProcessingOrders = f

	return mmGetProcessingOrders
}

// Return sets up results that will be returned by DB.GetProcessingOrders
func (mmGetProcessingOrders *mDBMockGetProcessingOrders) Return(ia1 []types.ID, err error) *DBMock {
	if mmGetProcessingOrders.mock.funcGetProcessingOrders != nil {
		mmGetProcessingOrders.mock.t.Fatalf("DBMock.GetProcessingOrders mock is already set by Set")
	}

	if mmGetProcessingOrders.defaultExpectation == nil {
		mmGetProcessingOrders.defaultExpectation = &DBMockGetProcessingOrdersExpectation{mock: mmGetProcessingOrders.mock}
	}
	mmGetProcessingOrders.defaultExpectation.results = &DBMockGetProcessingOrdersResults{ia1, err}
	return mmGetProcessingOrders.mock
}

//Set uses given function f to mock the DB.GetProcessingOrders method
func (mmGetProcessingOrders *mDBMockGetProcessingOrders) Set(f func(ctx context.Context, retries int) (ia1 []types.ID, err error)) *DBMock {
	if mmGetProcessingOrders.defaultExpectation != nil {
		mmGetProcessingOrders.mock.t.Fatalf("Default expectation is already set for the DB.GetProcessingOrders method")
	}

	if len(mmGetProcessingOrders.expectations) > 0 {
		mmGetProcessingOrders.mock.t.Fatalf("Some expectations are already set for the DB.GetProcessingOrders method")
	}

	mmGetProcessingOrders.mock.funcGetProcessingOrders = f
	return mmGetProcessingOrders.mock
}

// When sets expectation for the DB.GetProcessingOrders which will trigger the result defined by the following
// Then helper
func (mmGetProcessingOrders *mDBMockGetProcessingOrders) When(ctx context.Context, retries int) *DBMockGetProcessingOrdersExpectation {
	if mmGetProcessingOrders.mock.funcGetProcessingOrders != nil {
		mmGetProcessingOrders.mock.t.Fatalf("DBMock.GetProcessingOrders mock is already set by Set")
	}

	expectation := &DBMockGetProcessingOrdersExpectation{
		mock:   mmGetProcessingOrders.mock,
		params: &DBMockGetProcessingOrdersParams{ctx, retries},
	}
	mmGetProcessingOrders.expectations = append(mmGetProcessingOrders.expectations, expectation)
	return expectation
}

// Then sets up DB.GetProcessingOrders return parameters for the expectation previously defined by the When method
func (e *DBMockGetProcessingOrdersExpectation) Then(ia1 []types.ID, err error) *DBMock {
	e.results = &DBMockGetProcessingOrdersResults{ia1, err}
	return e.mock
}

// GetProcessingOrders implements DB
func (mmGetProcessingOrders *DBMock) GetProcessingOrders(ctx context.Context, retries int) (ia1 []types.ID, err error) {
	mm_atomic.AddUint64(&mmGetProcessingOrders.beforeGetProcessingOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProcessingOrders.afterGetProcessingOrdersCounter, 1)

	if mmGetProcessingOrders.inspectFuncGetProcessingOrders != nil {
		mmGetProcessingOrders.inspectFuncGetProcessingOrders(ctx, retries)
	}

	mm_params := &DBMockGetProcessingOrdersParams{ctx, retries}

	// Record call args
	mmGetProcessingOrders.GetProcessingOrdersMock.mutex.Lock()
	mmGetProcessingOrders.GetProcessingOrdersMock.callArgs = append(mmGetProcessingOrders.GetProcessingOrdersMock.callArgs, mm_params)
	mmGetProcessingOrders.GetProcessingOrdersMock.mutex.Unlock()

	for _, e := range mmGetProcessingOrders.GetProcessingOrdersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetProcessingOrders.GetProcessingOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProcessingOrders.GetProcessingOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProcessingOrders.GetProcessingOrdersMock.defaultExpectation.params
		mm_got := DBMockGetProcessingOrdersParams{ctx, retries}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProcessingOrders.t.Errorf("DBMock.GetProcessingOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProcessingOrders.GetProcessingOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProcessingOrders.t.Fatal("No results are set for the DBMock.GetProcessingOrders")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetProcessingOrders.funcGetProcessingOrders != nil {
		return mmGetProcessingOrders.funcGetProcessingOrders(ctx, retries)
	}
	mmGetProcessingOrders.t.Fatalf("Unexpected call to DBMock.GetProcessingOrders. %v %v", ctx, retries)
	return
}

// GetProcessingOrdersAfterCounter returns a count of finished DBMock.GetProcessingOrders invocations
func (mmGetProcessingOrders *DBMock) GetProcessingOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProcessingOrders.afterGetProcessingOrdersCounter)
}

// GetProcessingOrdersBeforeCounter returns a count of DBMock.GetProcessingOrders invocations
func (mmGetProcessingOrders *DBMock) GetProcessingOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProcessingOrders.beforeGetProcessingOrdersCounter)
}

// Calls returns a list of arguments used in each call to DBMock.GetProcessingOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProcessingOrders *mDBMockGetProcessingOrders) Calls() []*DBMockGetProcessingOrdersParams {
	mmGetProcessingOrders.mutex.RLock()

	argCopy := make([]*DBMockGetProcessingOrdersParams, len(mmGetProcessingOrders.callArgs))
	copy(argCopy, mmGetProcessingOrders.callArgs)

	mmGetProcessingOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGetProcessingOrdersDone returns true if the count of the GetProcessingOrders invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockGetProcessingOrdersDone() bool {
	for _, e := range m.GetProcessingOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProcessingOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProcessingOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProcessingOrders != nil && mm_atomic.LoadUint64(&m.afterGetProcessingOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProcessingOrdersInspect logs each unmet expectation
func (m *DBMock) MinimockGetProcessingOrdersInspect() {
	for _, e := range m.GetProcessingOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.GetProcessingOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProcessingOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProcessingOrdersCounter) < 1 {
		if m.GetProcessingOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.GetProcessingOrders")
		} else {
			m.t.Errorf("Expected call to DBMock.GetProcessingOrders with params: %#v", *m.GetProcessingOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProcessingOrders != nil && mm_atomic.LoadUint64(&m.afterGetProcessingOrdersCounter) < 1 {
		m.t.Error("Expected call to DBMock.GetProcessingOrders")
	}
}

type mDBMockUpdateOrderSagaStatus struct {
	mock               *DBMock
	defaultExpectation *DBMockUpdateOrderSagaStatusExpectation
	expectations       []*DBMockUpdateOrderSagaStatusExpectation

	callArgs []*DBMockUpdateOrderSagaStatusParams
	mutex    sync.RWMutex
}

// DBMockUpdateOrderSagaStatusExpectation specifies expectation struct of the DB.UpdateOrderSagaStatus
type DBMockUpdateOrderSagaStatusExpectation struct {
	mock    *DBMock
	params  *DBMockUpdateOrderSagaStatusParams
	results *DBMockUpdateOrderSagaStatusResults
	Counter uint64
}

// DBMockUpdateOrderSagaStatusParams contains parameters of the DB.UpdateOrderSagaStatus
type DBMockUpdateOrderSagaStatusParams struct {
	ctx   context.Context
	order *models.Order
}

// DBMockUpdateOrderSagaStatusResults contains results of the DB.UpdateOrderSagaStatus
type DBMockUpdateOrderSagaStatusResults struct {
	err error
}

// Expect sets up expected params for DB.UpdateOrderSagaStatus
func (mmUpdateOrderSagaStatus *mDBMockUpdateOrderSagaStatus) Expect(ctx context.Context, order *models.Order) *mDBMockUpdateOrderSagaStatus {
	if mmUpdateOrderSagaStatus.mock.funcUpdateOrderSagaStatus != nil {
		mmUpdateOrderSagaStatus.mock.t.Fatalf("DBMock.UpdateOrderSagaStatus mock is already set by Set")
	}

	if mmUpdateOrderSagaStatus.defaultExpectation == nil {
		mmUpdateOrderSagaStatus.defaultExpectation = &DBMockUpdateOrderSagaStatusExpectation{}
	}

	mmUpdateOrderSagaStatus.defaultExpectation.params = &DBMockUpdateOrderSagaStatusParams{ctx, order}
	for _, e := range mmUpdateOrderSagaStatus.expectations {
		if minimock.Equal(e.params, mmUpdateOrderSagaStatus.defaultExpectation.params) {
			mmUpdateOrderSagaStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderSagaStatus.defaultExpectation.params)
		}
	}

	return mmUpdateOrderSagaStatus
}

// Inspect accepts an inspector function that has same arguments as the DB.UpdateOrderSagaStatus
func (mmUpdateOrderSagaStatus *mDBMockUpdateOrderSagaStatus) Inspect(f func(ctx context.Context, order *models.Order)) *mDBMockUpdateOrderSagaStatus {
	if mmUpdateOrderSagaStatus.mock.inspectFuncUpdateOrderSagaStatus != nil {
		mmUpdateOrderSagaStatus.mock.t.Fatalf("Inspect function is already set for DBMock.UpdateOrderSagaStatus")
	}

	mmUpdateOrderSagaStatus.mock.inspectFuncUpdateOrderSagaStatus = f

	return mmUpdateOrderSagaStatus
}

// Return sets up results that will be returned by DB.UpdateOrderSagaStatus
func (mmUpdateOrderSagaStatus *mDBMockUpdateOrderSagaStatus) Return(err error) *DBMock {
	if mmUpdateOrderSagaStatus.mock.funcUpdateOrderSagaStatus != nil {
		mmUpdateOrderSagaStatus.mock.t.Fatalf("DBMock.UpdateOrderSagaStatus mock is already set by Set")
	}

	if mmUpdateOrderSagaStatus.defaultExpectation == nil {
		mmUpdateOrderSagaStatus.defaultExpectation = &DBMockUpdateOrderSagaStatusExpectation{mock: mmUpdateOrderSagaStatus.mock}
	}
	mmUpdateOrderSagaStatus.defaultExpectation.results = &DBMockUpdateOrderSagaStatusResults{err}
	return mmUpdateOrderSagaStatus.mock
}

//Set uses given function f to mock the DB.UpdateOrderSagaStatus method
func (mmUpdateOrderSagaStatus *mDBMockUpdateOrderSagaStatus) Set(f func(ctx context.Context, order *models.Order) (err error)) *DBMock {
	if mmUpdateOrderSagaStatus.defaultExpectation != nil {
		mmUpdateOrderSagaStatus.mock.t.Fatalf("Default expectation is already set for the DB.UpdateOrderSagaStatus method")
	}

	if len(mmUpdateOrderSagaStatus.expectations) > 0 {
		mmUpdateOrderSagaStatus.mock.t.Fatalf("Some expectations are already set for the DB.UpdateOrderSagaStatus method")
	}

	mmUpdateOrderSagaStatus.mock.funcUpdateOrderSagaStatus = f
	return mmUpdateOrderSagaStatus.mock
}

// When sets expectation for the DB.UpdateOrderSagaStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderSagaStatus *mDBMockUpdateOrderSagaStatus) When(ctx context.Context, order *models.Order) *DBMockUpdateOrderSagaStatusExpectation {
	if mmUpdateOrderSagaStatus.mock.funcUpdateOrderSagaStatus != nil {
		mmUpdateOrderSagaStatus.mock.t.Fatalf("DBMock.UpdateOrderSagaStatus mock is already set by Set")
	}

	expectation := &DBMockUpdateOrderSagaStatusExpectation{
		mock:   mmUpdateOrderSagaStatus.mock,
		params: &DBMockUpdateOrderSagaStatusParams{ctx, order},
	}
	mmUpdateOrderSagaStatus.expectations = append(mmUpdateOrderSagaStatus.expectations, expectation)
	return expectation
}

// Then sets up DB.UpdateOrderSagaStatus return parameters for the expectation previously defined by the When method
func (e *DBMockUpdateOrderSagaStatusExpectation) Then(err error) *DBMock {
	e.results = &DBMockUpdateOrderSagaStatusResults{err}
	return e.mock
}

// UpdateOrderSagaStatus implements DB
func (mmUpdateOrderSagaStatus *DBMock) UpdateOrderSagaStatus(ctx context.Context, order *models.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderSagaStatus.beforeUpdateOrderSagaStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderSagaStatus.afterUpdateOrderSagaStatusCounter, 1)

	if mmUpdateOrderSagaStatus.inspectFuncUpdateOrderSagaStatus != nil {
		mmUpdateOrderSagaStatus.inspectFuncUpdateOrderSagaStatus(ctx, order)
	}

	mm_params := &DBMockUpdateOrderSagaStatusParams{ctx, order}

	// Record call args
	mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.mutex.Lock()
	mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.callArgs = append(mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.callArgs, mm_params)
	mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.mutex.Unlock()

	for _, e := range mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.defaultExpectation.params
		mm_got := DBMockUpdateOrderSagaStatusParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderSagaStatus.t.Errorf("DBMock.UpdateOrderSagaStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderSagaStatus.UpdateOrderSagaStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrderSagaStatus.t.Fatal("No results are set for the DBMock.UpdateOrderSagaStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateOrderSagaStatus.funcUpdateOrderSagaStatus != nil {
		return mmUpdateOrderSagaStatus.funcUpdateOrderSagaStatus(ctx, order)
	}
	mmUpdateOrderSagaStatus.t.Fatalf("Unexpected call to DBMock.UpdateOrderSagaStatus. %v %v", ctx, order)
	return
}

// UpdateOrderSagaStatusAfterCounter returns a count of finished DBMock.UpdateOrderSagaStatus invocations
func (mmUpdateOrderSagaStatus *DBMock) UpdateOrderSagaStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderSagaStatus.afterUpdateOrderSagaStatusCounter)
}

// UpdateOrderSagaStatusBeforeCounter returns a count of DBMock.UpdateOrderSagaStatus invocations
func (mmUpdateOrderSagaStatus *DBMock) UpdateOrderSagaStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderSagaStatus.beforeUpdateOrderSagaStatusCounter)
}

// Calls returns a list of arguments used in each call to DBMock.UpdateOrderSagaStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderSagaStatus *mDBMockUpdateOrderSagaStatus) Calls() []*DBMockUpdateOrderSagaStatusParams {
	mmUpdateOrderSagaStatus.mutex.RLock()

	argCopy := make([]*DBMockUpdateOrderSagaStatusParams, len(mmUpdateOrderSagaStatus.callArgs))
	copy(argCopy, mmUpdateOrderSagaStatus.callArgs)

	mmUpdateOrderSagaStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderSagaStatusDone returns true if the count of the UpdateOrderSagaStatus invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockUpdateOrderSagaStatusDone() bool {
	for _, e := range m.UpdateOrderSagaStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderSagaStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderSagaStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderSagaStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderSagaStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderSagaStatusInspect logs each unmet expectation
func (m *DBMock) MinimockUpdateOrderSagaStatusInspect() {
	for _, e := range m.UpdateOrderSagaStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.UpdateOrderSagaStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderSagaStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderSagaStatusCounter) < 1 {
		if m.UpdateOrderSagaStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.UpdateOrderSagaStatus")
		} else {
			m.t.Errorf("Expected call to DBMock.UpdateOrderSagaStatus with params: %#v", *m.UpdateOrderSagaStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderSagaStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderSagaStatusCounter) < 1 {
		m.t.Error("Expected call to DBMock.UpdateOrderSagaStatus")
	}
}

type mDBMockUpdateStatus struct {
	mock               *DBMock
	defaultExpectation *DBMockUpdateStatusExpectation
	expectations       []*DBMockUpdateStatusExpectation

	callArgs []*DBMockUpdateStatusParams
	mutex    sync.RWMutex
}

// DBMockUpdateStatusExpectation specifies expectation struct of the DB.UpdateStatus
type DBMockUpdateStatusExpectation struct {
	mock    *DBMock
	params  *DBMockUpdateStatusParams
	results *DBMockUpdateStatusResults
	Counter uint64
}

// DBMockUpdateStatusParams contains parameters of the DB.UpdateStatus
type DBMockUpdateStatusParams struct {
	ctx context.Context
	op1 *models.Order
}

// DBMockUpdateStatusResults contains results of the DB.UpdateStatus
type DBMockUpdateStatusResults struct {
	err error
}

// Expect sets up expected params for DB.UpdateStatus
func (mmUpdateStatus *mDBMockUpdateStatus) Expect(ctx context.Context, op1 *models.Order) *mDBMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("DBMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &DBMockUpdateStatusExpectation{}
	}

	mmUpdateStatus.defaultExpectation.params = &DBMockUpdateStatusParams{ctx, op1}
	for _, e := range mmUpdateStatus.expectations {
		if minimock.Equal(e.params, mmUpdateStatus.defaultExpectation.params) {
			mmUpdateStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStatus.defaultExpectation.params)
		}
	}

	return mmUpdateStatus
}

// Inspect accepts an inspector function that has same arguments as the DB.UpdateStatus
func (mmUpdateStatus *mDBMockUpdateStatus) Inspect(f func(ctx context.Context, op1 *models.Order)) *mDBMockUpdateStatus {
	if mmUpdateStatus.mock.inspectFuncUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("Inspect function is already set for DBMock.UpdateStatus")
	}

	mmUpdateStatus.mock.inspectFuncUpdateStatus = f

	return mmUpdateStatus
}

// Return sets up results that will be returned by DB.UpdateStatus
func (mmUpdateStatus *mDBMockUpdateStatus) Return(err error) *DBMock {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("DBMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &DBMockUpdateStatusExpectation{mock: mmUpdateStatus.mock}
	}
	mmUpdateStatus.defaultExpectation.results = &DBMockUpdateStatusResults{err}
	return mmUpdateStatus.mock
}

//Set uses given function f to mock the DB.UpdateStatus method
func (mmUpdateStatus *mDBMockUpdateStatus) Set(f func(ctx context.Context, op1 *models.Order) (err error)) *DBMock {
	if mmUpdateStatus.defaultExpectation != nil {
		mmUpdateStatus.mock.t.Fatalf("Default expectation is already set for the DB.UpdateStatus method")
	}

	if len(mmUpdateStatus.expectations) > 0 {
		mmUpdateStatus.mock.t.Fatalf("Some expectations are already set for the DB.UpdateStatus method")
	}

	mmUpdateStatus.mock.funcUpdateStatus = f
	return mmUpdateStatus.mock
}

// When sets expectation for the DB.UpdateStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateStatus *mDBMockUpdateStatus) When(ctx context.Context, op1 *models.Order) *DBMockUpdateStatusExpectation {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("DBMock.UpdateStatus mock is already set by Set")
	}

	expectation := &DBMockUpdateStatusExpectation{
		mock:   mmUpdateStatus.mock,
		params: &DBMockUpdateStatusParams{ctx, op1},
	}
	mmUpdateStatus.expectations = append(mmUpdateStatus.expectations, expectation)
	return expectation
}

// Then sets up DB.UpdateStatus return parameters for the expectation previously defined by the When method
func (e *DBMockUpdateStatusExpectation) Then(err error) *DBMock {
	e.results = &DBMockUpdateStatusResults{err}
	return e.mock
}

// UpdateStatus implements DB
func (mmUpdateStatus *DBMock) UpdateStatus(ctx context.Context, op1 *models.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateStatus.beforeUpdateStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStatus.afterUpdateStatusCounter, 1)

	if mmUpdateStatus.inspectFuncUpdateStatus != nil {
		mmUpdateStatus.inspectFuncUpdateStatus(ctx, op1)
	}

	mm_params := &DBMockUpdateStatusParams{ctx, op1}

	// Record call args
	mmUpdateStatus.UpdateStatusMock.mutex.Lock()
	mmUpdateStatus.UpdateStatusMock.callArgs = append(mmUpdateStatus.UpdateStatusMock.callArgs, mm_params)
	mmUpdateStatus.UpdateStatusMock.mutex.Unlock()

	for _, e := range mmUpdateStatus.UpdateStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStatus.UpdateStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStatus.UpdateStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStatus.UpdateStatusMock.defaultExpectation.params
		mm_got := DBMockUpdateStatusParams{ctx, op1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStatus.t.Errorf("DBMock.UpdateStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStatus.UpdateStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStatus.t.Fatal("No results are set for the DBMock.UpdateStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateStatus.funcUpdateStatus != nil {
		return mmUpdateStatus.funcUpdateStatus(ctx, op1)
	}
	mmUpdateStatus.t.Fatalf("Unexpected call to DBMock.UpdateStatus. %v %v", ctx, op1)
	return
}

// UpdateStatusAfterCounter returns a count of finished DBMock.UpdateStatus invocations
func (mmUpdateStatus *DBMock) UpdateStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatus.afterUpdateStatusCounter)
}

// UpdateStatusBeforeCounter returns a count of DBMock.UpdateStatus invocations
func (mmUpdateStatus *DBMock) UpdateStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatus.beforeUpdateStatusCounter)
}

// Calls returns a list of arguments used in each call to DBMock.UpdateStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStatus *mDBMockUpdateStatus) Calls() []*DBMockUpdateStatusParams {
	mmUpdateStatus.mutex.RLock()

	argCopy := make([]*DBMockUpdateStatusParams, len(mmUpdateStatus.callArgs))
	copy(argCopy, mmUpdateStatus.callArgs)

	mmUpdateStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStatusDone returns true if the count of the UpdateStatus invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockUpdateStatusDone() bool {
	for _, e := range m.UpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateStatusInspect logs each unmet expectation
func (m *DBMock) MinimockUpdateStatusInspect() {
	for _, e := range m.UpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.UpdateStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStatusCounter) < 1 {
		if m.UpdateStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.UpdateStatus")
		} else {
			m.t.Errorf("Expected call to DBMock.UpdateStatus with params: %#v", *m.UpdateStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateStatusCounter) < 1 {
		m.t.Error("Expected call to DBMock.UpdateStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddRetryInspect()

		m.MinimockCheckStatusInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockGetOrderInspect()

		m.MinimockGetProcessingOrdersInspect()

		m.MinimockUpdateOrderSagaStatusInspect()

		m.MinimockUpdateStatusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddRetryDone() &&
		m.MinimockCheckStatusDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetProcessingOrdersDone() &&
		m.MinimockUpdateOrderSagaStatusDone() &&
		m.MinimockUpdateStatusDone()
}
