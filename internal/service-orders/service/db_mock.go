package service

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/lvjonok/homework-3/internal/service-orders/service.DB -o ./db_mock.go -n DBMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	types "gitlab.ozon.dev/lvjonok/homework-3/core/models"
	"gitlab.ozon.dev/lvjonok/homework-3/internal/service-orders/models"
)

// DBMock implements DB
type DBMock struct {
	t minimock.Tester

	funcCheckStatus          func(ctx context.Context, ip1 *types.ID) (s1 string, err error)
	inspectFuncCheckStatus   func(ctx context.Context, ip1 *types.ID)
	afterCheckStatusCounter  uint64
	beforeCheckStatusCounter uint64
	CheckStatusMock          mDBMockCheckStatus

	funcCreateOrder          func(ctx context.Context, op1 *models.Order) (ip1 *types.ID, err error)
	inspectFuncCreateOrder   func(ctx context.Context, op1 *models.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mDBMockCreateOrder

	funcUpdateStatus          func(ctx context.Context, op1 *models.Order) (err error)
	inspectFuncUpdateStatus   func(ctx context.Context, op1 *models.Order)
	afterUpdateStatusCounter  uint64
	beforeUpdateStatusCounter uint64
	UpdateStatusMock          mDBMockUpdateStatus
}

// NewDBMock returns a mock for DB
func NewDBMock(t minimock.Tester) *DBMock {
	m := &DBMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckStatusMock = mDBMockCheckStatus{mock: m}
	m.CheckStatusMock.callArgs = []*DBMockCheckStatusParams{}

	m.CreateOrderMock = mDBMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*DBMockCreateOrderParams{}

	m.UpdateStatusMock = mDBMockUpdateStatus{mock: m}
	m.UpdateStatusMock.callArgs = []*DBMockUpdateStatusParams{}

	return m
}

type mDBMockCheckStatus struct {
	mock               *DBMock
	defaultExpectation *DBMockCheckStatusExpectation
	expectations       []*DBMockCheckStatusExpectation

	callArgs []*DBMockCheckStatusParams
	mutex    sync.RWMutex
}

// DBMockCheckStatusExpectation specifies expectation struct of the DB.CheckStatus
type DBMockCheckStatusExpectation struct {
	mock    *DBMock
	params  *DBMockCheckStatusParams
	results *DBMockCheckStatusResults
	Counter uint64
}

// DBMockCheckStatusParams contains parameters of the DB.CheckStatus
type DBMockCheckStatusParams struct {
	ctx context.Context
	ip1 *types.ID
}

// DBMockCheckStatusResults contains results of the DB.CheckStatus
type DBMockCheckStatusResults struct {
	s1  string
	err error
}

// Expect sets up expected params for DB.CheckStatus
func (mmCheckStatus *mDBMockCheckStatus) Expect(ctx context.Context, ip1 *types.ID) *mDBMockCheckStatus {
	if mmCheckStatus.mock.funcCheckStatus != nil {
		mmCheckStatus.mock.t.Fatalf("DBMock.CheckStatus mock is already set by Set")
	}

	if mmCheckStatus.defaultExpectation == nil {
		mmCheckStatus.defaultExpectation = &DBMockCheckStatusExpectation{}
	}

	mmCheckStatus.defaultExpectation.params = &DBMockCheckStatusParams{ctx, ip1}
	for _, e := range mmCheckStatus.expectations {
		if minimock.Equal(e.params, mmCheckStatus.defaultExpectation.params) {
			mmCheckStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckStatus.defaultExpectation.params)
		}
	}

	return mmCheckStatus
}

// Inspect accepts an inspector function that has same arguments as the DB.CheckStatus
func (mmCheckStatus *mDBMockCheckStatus) Inspect(f func(ctx context.Context, ip1 *types.ID)) *mDBMockCheckStatus {
	if mmCheckStatus.mock.inspectFuncCheckStatus != nil {
		mmCheckStatus.mock.t.Fatalf("Inspect function is already set for DBMock.CheckStatus")
	}

	mmCheckStatus.mock.inspectFuncCheckStatus = f

	return mmCheckStatus
}

// Return sets up results that will be returned by DB.CheckStatus
func (mmCheckStatus *mDBMockCheckStatus) Return(s1 string, err error) *DBMock {
	if mmCheckStatus.mock.funcCheckStatus != nil {
		mmCheckStatus.mock.t.Fatalf("DBMock.CheckStatus mock is already set by Set")
	}

	if mmCheckStatus.defaultExpectation == nil {
		mmCheckStatus.defaultExpectation = &DBMockCheckStatusExpectation{mock: mmCheckStatus.mock}
	}
	mmCheckStatus.defaultExpectation.results = &DBMockCheckStatusResults{s1, err}
	return mmCheckStatus.mock
}

//Set uses given function f to mock the DB.CheckStatus method
func (mmCheckStatus *mDBMockCheckStatus) Set(f func(ctx context.Context, ip1 *types.ID) (s1 string, err error)) *DBMock {
	if mmCheckStatus.defaultExpectation != nil {
		mmCheckStatus.mock.t.Fatalf("Default expectation is already set for the DB.CheckStatus method")
	}

	if len(mmCheckStatus.expectations) > 0 {
		mmCheckStatus.mock.t.Fatalf("Some expectations are already set for the DB.CheckStatus method")
	}

	mmCheckStatus.mock.funcCheckStatus = f
	return mmCheckStatus.mock
}

// When sets expectation for the DB.CheckStatus which will trigger the result defined by the following
// Then helper
func (mmCheckStatus *mDBMockCheckStatus) When(ctx context.Context, ip1 *types.ID) *DBMockCheckStatusExpectation {
	if mmCheckStatus.mock.funcCheckStatus != nil {
		mmCheckStatus.mock.t.Fatalf("DBMock.CheckStatus mock is already set by Set")
	}

	expectation := &DBMockCheckStatusExpectation{
		mock:   mmCheckStatus.mock,
		params: &DBMockCheckStatusParams{ctx, ip1},
	}
	mmCheckStatus.expectations = append(mmCheckStatus.expectations, expectation)
	return expectation
}

// Then sets up DB.CheckStatus return parameters for the expectation previously defined by the When method
func (e *DBMockCheckStatusExpectation) Then(s1 string, err error) *DBMock {
	e.results = &DBMockCheckStatusResults{s1, err}
	return e.mock
}

// CheckStatus implements DB
func (mmCheckStatus *DBMock) CheckStatus(ctx context.Context, ip1 *types.ID) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCheckStatus.beforeCheckStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckStatus.afterCheckStatusCounter, 1)

	if mmCheckStatus.inspectFuncCheckStatus != nil {
		mmCheckStatus.inspectFuncCheckStatus(ctx, ip1)
	}

	mm_params := &DBMockCheckStatusParams{ctx, ip1}

	// Record call args
	mmCheckStatus.CheckStatusMock.mutex.Lock()
	mmCheckStatus.CheckStatusMock.callArgs = append(mmCheckStatus.CheckStatusMock.callArgs, mm_params)
	mmCheckStatus.CheckStatusMock.mutex.Unlock()

	for _, e := range mmCheckStatus.CheckStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCheckStatus.CheckStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckStatus.CheckStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckStatus.CheckStatusMock.defaultExpectation.params
		mm_got := DBMockCheckStatusParams{ctx, ip1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckStatus.t.Errorf("DBMock.CheckStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckStatus.CheckStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckStatus.t.Fatal("No results are set for the DBMock.CheckStatus")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCheckStatus.funcCheckStatus != nil {
		return mmCheckStatus.funcCheckStatus(ctx, ip1)
	}
	mmCheckStatus.t.Fatalf("Unexpected call to DBMock.CheckStatus. %v %v", ctx, ip1)
	return
}

// CheckStatusAfterCounter returns a count of finished DBMock.CheckStatus invocations
func (mmCheckStatus *DBMock) CheckStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckStatus.afterCheckStatusCounter)
}

// CheckStatusBeforeCounter returns a count of DBMock.CheckStatus invocations
func (mmCheckStatus *DBMock) CheckStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckStatus.beforeCheckStatusCounter)
}

// Calls returns a list of arguments used in each call to DBMock.CheckStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckStatus *mDBMockCheckStatus) Calls() []*DBMockCheckStatusParams {
	mmCheckStatus.mutex.RLock()

	argCopy := make([]*DBMockCheckStatusParams, len(mmCheckStatus.callArgs))
	copy(argCopy, mmCheckStatus.callArgs)

	mmCheckStatus.mutex.RUnlock()

	return argCopy
}

// MinimockCheckStatusDone returns true if the count of the CheckStatus invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCheckStatusDone() bool {
	for _, e := range m.CheckStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckStatus != nil && mm_atomic.LoadUint64(&m.afterCheckStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckStatusInspect logs each unmet expectation
func (m *DBMock) MinimockCheckStatusInspect() {
	for _, e := range m.CheckStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.CheckStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckStatusCounter) < 1 {
		if m.CheckStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.CheckStatus")
		} else {
			m.t.Errorf("Expected call to DBMock.CheckStatus with params: %#v", *m.CheckStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckStatus != nil && mm_atomic.LoadUint64(&m.afterCheckStatusCounter) < 1 {
		m.t.Error("Expected call to DBMock.CheckStatus")
	}
}

type mDBMockCreateOrder struct {
	mock               *DBMock
	defaultExpectation *DBMockCreateOrderExpectation
	expectations       []*DBMockCreateOrderExpectation

	callArgs []*DBMockCreateOrderParams
	mutex    sync.RWMutex
}

// DBMockCreateOrderExpectation specifies expectation struct of the DB.CreateOrder
type DBMockCreateOrderExpectation struct {
	mock    *DBMock
	params  *DBMockCreateOrderParams
	results *DBMockCreateOrderResults
	Counter uint64
}

// DBMockCreateOrderParams contains parameters of the DB.CreateOrder
type DBMockCreateOrderParams struct {
	ctx context.Context
	op1 *models.Order
}

// DBMockCreateOrderResults contains results of the DB.CreateOrder
type DBMockCreateOrderResults struct {
	ip1 *types.ID
	err error
}

// Expect sets up expected params for DB.CreateOrder
func (mmCreateOrder *mDBMockCreateOrder) Expect(ctx context.Context, op1 *models.Order) *mDBMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("DBMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &DBMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &DBMockCreateOrderParams{ctx, op1}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the DB.CreateOrder
func (mmCreateOrder *mDBMockCreateOrder) Inspect(f func(ctx context.Context, op1 *models.Order)) *mDBMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for DBMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by DB.CreateOrder
func (mmCreateOrder *mDBMockCreateOrder) Return(ip1 *types.ID, err error) *DBMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("DBMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &DBMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &DBMockCreateOrderResults{ip1, err}
	return mmCreateOrder.mock
}

//Set uses given function f to mock the DB.CreateOrder method
func (mmCreateOrder *mDBMockCreateOrder) Set(f func(ctx context.Context, op1 *models.Order) (ip1 *types.ID, err error)) *DBMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the DB.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the DB.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the DB.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mDBMockCreateOrder) When(ctx context.Context, op1 *models.Order) *DBMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("DBMock.CreateOrder mock is already set by Set")
	}

	expectation := &DBMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &DBMockCreateOrderParams{ctx, op1},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up DB.CreateOrder return parameters for the expectation previously defined by the When method
func (e *DBMockCreateOrderExpectation) Then(ip1 *types.ID, err error) *DBMock {
	e.results = &DBMockCreateOrderResults{ip1, err}
	return e.mock
}

// CreateOrder implements DB
func (mmCreateOrder *DBMock) CreateOrder(ctx context.Context, op1 *models.Order) (ip1 *types.ID, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, op1)
	}

	mm_params := &DBMockCreateOrderParams{ctx, op1}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := DBMockCreateOrderParams{ctx, op1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("DBMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the DBMock.CreateOrder")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, op1)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to DBMock.CreateOrder. %v %v", ctx, op1)
	return
}

// CreateOrderAfterCounter returns a count of finished DBMock.CreateOrder invocations
func (mmCreateOrder *DBMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of DBMock.CreateOrder invocations
func (mmCreateOrder *DBMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to DBMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mDBMockCreateOrder) Calls() []*DBMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*DBMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *DBMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to DBMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to DBMock.CreateOrder")
	}
}

type mDBMockUpdateStatus struct {
	mock               *DBMock
	defaultExpectation *DBMockUpdateStatusExpectation
	expectations       []*DBMockUpdateStatusExpectation

	callArgs []*DBMockUpdateStatusParams
	mutex    sync.RWMutex
}

// DBMockUpdateStatusExpectation specifies expectation struct of the DB.UpdateStatus
type DBMockUpdateStatusExpectation struct {
	mock    *DBMock
	params  *DBMockUpdateStatusParams
	results *DBMockUpdateStatusResults
	Counter uint64
}

// DBMockUpdateStatusParams contains parameters of the DB.UpdateStatus
type DBMockUpdateStatusParams struct {
	ctx context.Context
	op1 *models.Order
}

// DBMockUpdateStatusResults contains results of the DB.UpdateStatus
type DBMockUpdateStatusResults struct {
	err error
}

// Expect sets up expected params for DB.UpdateStatus
func (mmUpdateStatus *mDBMockUpdateStatus) Expect(ctx context.Context, op1 *models.Order) *mDBMockUpdateStatus {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("DBMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &DBMockUpdateStatusExpectation{}
	}

	mmUpdateStatus.defaultExpectation.params = &DBMockUpdateStatusParams{ctx, op1}
	for _, e := range mmUpdateStatus.expectations {
		if minimock.Equal(e.params, mmUpdateStatus.defaultExpectation.params) {
			mmUpdateStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateStatus.defaultExpectation.params)
		}
	}

	return mmUpdateStatus
}

// Inspect accepts an inspector function that has same arguments as the DB.UpdateStatus
func (mmUpdateStatus *mDBMockUpdateStatus) Inspect(f func(ctx context.Context, op1 *models.Order)) *mDBMockUpdateStatus {
	if mmUpdateStatus.mock.inspectFuncUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("Inspect function is already set for DBMock.UpdateStatus")
	}

	mmUpdateStatus.mock.inspectFuncUpdateStatus = f

	return mmUpdateStatus
}

// Return sets up results that will be returned by DB.UpdateStatus
func (mmUpdateStatus *mDBMockUpdateStatus) Return(err error) *DBMock {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("DBMock.UpdateStatus mock is already set by Set")
	}

	if mmUpdateStatus.defaultExpectation == nil {
		mmUpdateStatus.defaultExpectation = &DBMockUpdateStatusExpectation{mock: mmUpdateStatus.mock}
	}
	mmUpdateStatus.defaultExpectation.results = &DBMockUpdateStatusResults{err}
	return mmUpdateStatus.mock
}

//Set uses given function f to mock the DB.UpdateStatus method
func (mmUpdateStatus *mDBMockUpdateStatus) Set(f func(ctx context.Context, op1 *models.Order) (err error)) *DBMock {
	if mmUpdateStatus.defaultExpectation != nil {
		mmUpdateStatus.mock.t.Fatalf("Default expectation is already set for the DB.UpdateStatus method")
	}

	if len(mmUpdateStatus.expectations) > 0 {
		mmUpdateStatus.mock.t.Fatalf("Some expectations are already set for the DB.UpdateStatus method")
	}

	mmUpdateStatus.mock.funcUpdateStatus = f
	return mmUpdateStatus.mock
}

// When sets expectation for the DB.UpdateStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateStatus *mDBMockUpdateStatus) When(ctx context.Context, op1 *models.Order) *DBMockUpdateStatusExpectation {
	if mmUpdateStatus.mock.funcUpdateStatus != nil {
		mmUpdateStatus.mock.t.Fatalf("DBMock.UpdateStatus mock is already set by Set")
	}

	expectation := &DBMockUpdateStatusExpectation{
		mock:   mmUpdateStatus.mock,
		params: &DBMockUpdateStatusParams{ctx, op1},
	}
	mmUpdateStatus.expectations = append(mmUpdateStatus.expectations, expectation)
	return expectation
}

// Then sets up DB.UpdateStatus return parameters for the expectation previously defined by the When method
func (e *DBMockUpdateStatusExpectation) Then(err error) *DBMock {
	e.results = &DBMockUpdateStatusResults{err}
	return e.mock
}

// UpdateStatus implements DB
func (mmUpdateStatus *DBMock) UpdateStatus(ctx context.Context, op1 *models.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateStatus.beforeUpdateStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateStatus.afterUpdateStatusCounter, 1)

	if mmUpdateStatus.inspectFuncUpdateStatus != nil {
		mmUpdateStatus.inspectFuncUpdateStatus(ctx, op1)
	}

	mm_params := &DBMockUpdateStatusParams{ctx, op1}

	// Record call args
	mmUpdateStatus.UpdateStatusMock.mutex.Lock()
	mmUpdateStatus.UpdateStatusMock.callArgs = append(mmUpdateStatus.UpdateStatusMock.callArgs, mm_params)
	mmUpdateStatus.UpdateStatusMock.mutex.Unlock()

	for _, e := range mmUpdateStatus.UpdateStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateStatus.UpdateStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateStatus.UpdateStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateStatus.UpdateStatusMock.defaultExpectation.params
		mm_got := DBMockUpdateStatusParams{ctx, op1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateStatus.t.Errorf("DBMock.UpdateStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateStatus.UpdateStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateStatus.t.Fatal("No results are set for the DBMock.UpdateStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateStatus.funcUpdateStatus != nil {
		return mmUpdateStatus.funcUpdateStatus(ctx, op1)
	}
	mmUpdateStatus.t.Fatalf("Unexpected call to DBMock.UpdateStatus. %v %v", ctx, op1)
	return
}

// UpdateStatusAfterCounter returns a count of finished DBMock.UpdateStatus invocations
func (mmUpdateStatus *DBMock) UpdateStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatus.afterUpdateStatusCounter)
}

// UpdateStatusBeforeCounter returns a count of DBMock.UpdateStatus invocations
func (mmUpdateStatus *DBMock) UpdateStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateStatus.beforeUpdateStatusCounter)
}

// Calls returns a list of arguments used in each call to DBMock.UpdateStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateStatus *mDBMockUpdateStatus) Calls() []*DBMockUpdateStatusParams {
	mmUpdateStatus.mutex.RLock()

	argCopy := make([]*DBMockUpdateStatusParams, len(mmUpdateStatus.callArgs))
	copy(argCopy, mmUpdateStatus.callArgs)

	mmUpdateStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateStatusDone returns true if the count of the UpdateStatus invocations corresponds
// the number of defined expectations
func (m *DBMock) MinimockUpdateStatusDone() bool {
	for _, e := range m.UpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateStatusInspect logs each unmet expectation
func (m *DBMock) MinimockUpdateStatusInspect() {
	for _, e := range m.UpdateStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DBMock.UpdateStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateStatusCounter) < 1 {
		if m.UpdateStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DBMock.UpdateStatus")
		} else {
			m.t.Errorf("Expected call to DBMock.UpdateStatus with params: %#v", *m.UpdateStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateStatusCounter) < 1 {
		m.t.Error("Expected call to DBMock.UpdateStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DBMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCheckStatusInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockUpdateStatusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckStatusDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockUpdateStatusDone()
}
