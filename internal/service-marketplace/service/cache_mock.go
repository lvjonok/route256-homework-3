package service

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/lvjonok/homework-3/internal/service-marketplace/service.Cache -o ./cache_mock.go -n CacheMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	types "gitlab.ozon.dev/lvjonok/homework-3/core/models"
	"gitlab.ozon.dev/lvjonok/homework-3/internal/service-marketplace/models"
)

// CacheMock implements Cache
type CacheMock struct {
	t minimock.Tester

	funcAppendReview          func(ctx context.Context, r1 models.Review) (err error)
	inspectFuncAppendReview   func(ctx context.Context, r1 models.Review)
	afterAppendReviewCounter  uint64
	beforeAppendReviewCounter uint64
	AppendReviewMock          mCacheMockAppendReview

	funcGetCart          func(ctx context.Context, i1 types.ID) (cp1 *models.Cart, err error)
	inspectFuncGetCart   func(ctx context.Context, i1 types.ID)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCacheMockGetCart

	funcGetProduct          func(ctx context.Context, i1 types.ID) (pp1 *models.Product, err error)
	inspectFuncGetProduct   func(ctx context.Context, i1 types.ID)
	afterGetProductCounter  uint64
	beforeGetProductCounter uint64
	GetProductMock          mCacheMockGetProduct

	funcGetReviews          func(ctx context.Context, i1 types.ID) (ra1 []models.Review, err error)
	inspectFuncGetReviews   func(ctx context.Context, i1 types.ID)
	afterGetReviewsCounter  uint64
	beforeGetReviewsCounter uint64
	GetReviewsMock          mCacheMockGetReviews

	funcUpsertCart          func(ctx context.Context, c2 models.Cart) (err error)
	inspectFuncUpsertCart   func(ctx context.Context, c2 models.Cart)
	afterUpsertCartCounter  uint64
	beforeUpsertCartCounter uint64
	UpsertCartMock          mCacheMockUpsertCart

	funcUpsertProduct          func(ctx context.Context, p1 models.Product) (err error)
	inspectFuncUpsertProduct   func(ctx context.Context, p1 models.Product)
	afterUpsertProductCounter  uint64
	beforeUpsertProductCounter uint64
	UpsertProductMock          mCacheMockUpsertProduct

	funcUpsertReviews          func(ctx context.Context, i1 types.ID, ra1 []models.Review) (err error)
	inspectFuncUpsertReviews   func(ctx context.Context, i1 types.ID, ra1 []models.Review)
	afterUpsertReviewsCounter  uint64
	beforeUpsertReviewsCounter uint64
	UpsertReviewsMock          mCacheMockUpsertReviews
}

// NewCacheMock returns a mock for Cache
func NewCacheMock(t minimock.Tester) *CacheMock {
	m := &CacheMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AppendReviewMock = mCacheMockAppendReview{mock: m}
	m.AppendReviewMock.callArgs = []*CacheMockAppendReviewParams{}

	m.GetCartMock = mCacheMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CacheMockGetCartParams{}

	m.GetProductMock = mCacheMockGetProduct{mock: m}
	m.GetProductMock.callArgs = []*CacheMockGetProductParams{}

	m.GetReviewsMock = mCacheMockGetReviews{mock: m}
	m.GetReviewsMock.callArgs = []*CacheMockGetReviewsParams{}

	m.UpsertCartMock = mCacheMockUpsertCart{mock: m}
	m.UpsertCartMock.callArgs = []*CacheMockUpsertCartParams{}

	m.UpsertProductMock = mCacheMockUpsertProduct{mock: m}
	m.UpsertProductMock.callArgs = []*CacheMockUpsertProductParams{}

	m.UpsertReviewsMock = mCacheMockUpsertReviews{mock: m}
	m.UpsertReviewsMock.callArgs = []*CacheMockUpsertReviewsParams{}

	return m
}

type mCacheMockAppendReview struct {
	mock               *CacheMock
	defaultExpectation *CacheMockAppendReviewExpectation
	expectations       []*CacheMockAppendReviewExpectation

	callArgs []*CacheMockAppendReviewParams
	mutex    sync.RWMutex
}

// CacheMockAppendReviewExpectation specifies expectation struct of the Cache.AppendReview
type CacheMockAppendReviewExpectation struct {
	mock    *CacheMock
	params  *CacheMockAppendReviewParams
	results *CacheMockAppendReviewResults
	Counter uint64
}

// CacheMockAppendReviewParams contains parameters of the Cache.AppendReview
type CacheMockAppendReviewParams struct {
	ctx context.Context
	r1  models.Review
}

// CacheMockAppendReviewResults contains results of the Cache.AppendReview
type CacheMockAppendReviewResults struct {
	err error
}

// Expect sets up expected params for Cache.AppendReview
func (mmAppendReview *mCacheMockAppendReview) Expect(ctx context.Context, r1 models.Review) *mCacheMockAppendReview {
	if mmAppendReview.mock.funcAppendReview != nil {
		mmAppendReview.mock.t.Fatalf("CacheMock.AppendReview mock is already set by Set")
	}

	if mmAppendReview.defaultExpectation == nil {
		mmAppendReview.defaultExpectation = &CacheMockAppendReviewExpectation{}
	}

	mmAppendReview.defaultExpectation.params = &CacheMockAppendReviewParams{ctx, r1}
	for _, e := range mmAppendReview.expectations {
		if minimock.Equal(e.params, mmAppendReview.defaultExpectation.params) {
			mmAppendReview.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAppendReview.defaultExpectation.params)
		}
	}

	return mmAppendReview
}

// Inspect accepts an inspector function that has same arguments as the Cache.AppendReview
func (mmAppendReview *mCacheMockAppendReview) Inspect(f func(ctx context.Context, r1 models.Review)) *mCacheMockAppendReview {
	if mmAppendReview.mock.inspectFuncAppendReview != nil {
		mmAppendReview.mock.t.Fatalf("Inspect function is already set for CacheMock.AppendReview")
	}

	mmAppendReview.mock.inspectFuncAppendReview = f

	return mmAppendReview
}

// Return sets up results that will be returned by Cache.AppendReview
func (mmAppendReview *mCacheMockAppendReview) Return(err error) *CacheMock {
	if mmAppendReview.mock.funcAppendReview != nil {
		mmAppendReview.mock.t.Fatalf("CacheMock.AppendReview mock is already set by Set")
	}

	if mmAppendReview.defaultExpectation == nil {
		mmAppendReview.defaultExpectation = &CacheMockAppendReviewExpectation{mock: mmAppendReview.mock}
	}
	mmAppendReview.defaultExpectation.results = &CacheMockAppendReviewResults{err}
	return mmAppendReview.mock
}

//Set uses given function f to mock the Cache.AppendReview method
func (mmAppendReview *mCacheMockAppendReview) Set(f func(ctx context.Context, r1 models.Review) (err error)) *CacheMock {
	if mmAppendReview.defaultExpectation != nil {
		mmAppendReview.mock.t.Fatalf("Default expectation is already set for the Cache.AppendReview method")
	}

	if len(mmAppendReview.expectations) > 0 {
		mmAppendReview.mock.t.Fatalf("Some expectations are already set for the Cache.AppendReview method")
	}

	mmAppendReview.mock.funcAppendReview = f
	return mmAppendReview.mock
}

// When sets expectation for the Cache.AppendReview which will trigger the result defined by the following
// Then helper
func (mmAppendReview *mCacheMockAppendReview) When(ctx context.Context, r1 models.Review) *CacheMockAppendReviewExpectation {
	if mmAppendReview.mock.funcAppendReview != nil {
		mmAppendReview.mock.t.Fatalf("CacheMock.AppendReview mock is already set by Set")
	}

	expectation := &CacheMockAppendReviewExpectation{
		mock:   mmAppendReview.mock,
		params: &CacheMockAppendReviewParams{ctx, r1},
	}
	mmAppendReview.expectations = append(mmAppendReview.expectations, expectation)
	return expectation
}

// Then sets up Cache.AppendReview return parameters for the expectation previously defined by the When method
func (e *CacheMockAppendReviewExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockAppendReviewResults{err}
	return e.mock
}

// AppendReview implements Cache
func (mmAppendReview *CacheMock) AppendReview(ctx context.Context, r1 models.Review) (err error) {
	mm_atomic.AddUint64(&mmAppendReview.beforeAppendReviewCounter, 1)
	defer mm_atomic.AddUint64(&mmAppendReview.afterAppendReviewCounter, 1)

	if mmAppendReview.inspectFuncAppendReview != nil {
		mmAppendReview.inspectFuncAppendReview(ctx, r1)
	}

	mm_params := &CacheMockAppendReviewParams{ctx, r1}

	// Record call args
	mmAppendReview.AppendReviewMock.mutex.Lock()
	mmAppendReview.AppendReviewMock.callArgs = append(mmAppendReview.AppendReviewMock.callArgs, mm_params)
	mmAppendReview.AppendReviewMock.mutex.Unlock()

	for _, e := range mmAppendReview.AppendReviewMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAppendReview.AppendReviewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAppendReview.AppendReviewMock.defaultExpectation.Counter, 1)
		mm_want := mmAppendReview.AppendReviewMock.defaultExpectation.params
		mm_got := CacheMockAppendReviewParams{ctx, r1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAppendReview.t.Errorf("CacheMock.AppendReview got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAppendReview.AppendReviewMock.defaultExpectation.results
		if mm_results == nil {
			mmAppendReview.t.Fatal("No results are set for the CacheMock.AppendReview")
		}
		return (*mm_results).err
	}
	if mmAppendReview.funcAppendReview != nil {
		return mmAppendReview.funcAppendReview(ctx, r1)
	}
	mmAppendReview.t.Fatalf("Unexpected call to CacheMock.AppendReview. %v %v", ctx, r1)
	return
}

// AppendReviewAfterCounter returns a count of finished CacheMock.AppendReview invocations
func (mmAppendReview *CacheMock) AppendReviewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppendReview.afterAppendReviewCounter)
}

// AppendReviewBeforeCounter returns a count of CacheMock.AppendReview invocations
func (mmAppendReview *CacheMock) AppendReviewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAppendReview.beforeAppendReviewCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.AppendReview.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAppendReview *mCacheMockAppendReview) Calls() []*CacheMockAppendReviewParams {
	mmAppendReview.mutex.RLock()

	argCopy := make([]*CacheMockAppendReviewParams, len(mmAppendReview.callArgs))
	copy(argCopy, mmAppendReview.callArgs)

	mmAppendReview.mutex.RUnlock()

	return argCopy
}

// MinimockAppendReviewDone returns true if the count of the AppendReview invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockAppendReviewDone() bool {
	for _, e := range m.AppendReviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AppendReviewMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAppendReviewCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAppendReview != nil && mm_atomic.LoadUint64(&m.afterAppendReviewCounter) < 1 {
		return false
	}
	return true
}

// MinimockAppendReviewInspect logs each unmet expectation
func (m *CacheMock) MinimockAppendReviewInspect() {
	for _, e := range m.AppendReviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.AppendReview with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AppendReviewMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAppendReviewCounter) < 1 {
		if m.AppendReviewMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.AppendReview")
		} else {
			m.t.Errorf("Expected call to CacheMock.AppendReview with params: %#v", *m.AppendReviewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAppendReview != nil && mm_atomic.LoadUint64(&m.afterAppendReviewCounter) < 1 {
		m.t.Error("Expected call to CacheMock.AppendReview")
	}
}

type mCacheMockGetCart struct {
	mock               *CacheMock
	defaultExpectation *CacheMockGetCartExpectation
	expectations       []*CacheMockGetCartExpectation

	callArgs []*CacheMockGetCartParams
	mutex    sync.RWMutex
}

// CacheMockGetCartExpectation specifies expectation struct of the Cache.GetCart
type CacheMockGetCartExpectation struct {
	mock    *CacheMock
	params  *CacheMockGetCartParams
	results *CacheMockGetCartResults
	Counter uint64
}

// CacheMockGetCartParams contains parameters of the Cache.GetCart
type CacheMockGetCartParams struct {
	ctx context.Context
	i1  types.ID
}

// CacheMockGetCartResults contains results of the Cache.GetCart
type CacheMockGetCartResults struct {
	cp1 *models.Cart
	err error
}

// Expect sets up expected params for Cache.GetCart
func (mmGetCart *mCacheMockGetCart) Expect(ctx context.Context, i1 types.ID) *mCacheMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CacheMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CacheMockGetCartExpectation{}
	}

	mmGetCart.defaultExpectation.params = &CacheMockGetCartParams{ctx, i1}
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the Cache.GetCart
func (mmGetCart *mCacheMockGetCart) Inspect(f func(ctx context.Context, i1 types.ID)) *mCacheMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CacheMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by Cache.GetCart
func (mmGetCart *mCacheMockGetCart) Return(cp1 *models.Cart, err error) *CacheMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CacheMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CacheMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CacheMockGetCartResults{cp1, err}
	return mmGetCart.mock
}

//Set uses given function f to mock the Cache.GetCart method
func (mmGetCart *mCacheMockGetCart) Set(f func(ctx context.Context, i1 types.ID) (cp1 *models.Cart, err error)) *CacheMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the Cache.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the Cache.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	return mmGetCart.mock
}

// When sets expectation for the Cache.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCacheMockGetCart) When(ctx context.Context, i1 types.ID) *CacheMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CacheMock.GetCart mock is already set by Set")
	}

	expectation := &CacheMockGetCartExpectation{
		mock:   mmGetCart.mock,
		params: &CacheMockGetCartParams{ctx, i1},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up Cache.GetCart return parameters for the expectation previously defined by the When method
func (e *CacheMockGetCartExpectation) Then(cp1 *models.Cart, err error) *CacheMock {
	e.results = &CacheMockGetCartResults{cp1, err}
	return e.mock
}

// GetCart implements Cache
func (mmGetCart *CacheMock) GetCart(ctx context.Context, i1 types.ID) (cp1 *models.Cart, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, i1)
	}

	mm_params := &CacheMockGetCartParams{ctx, i1}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_got := CacheMockGetCartParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CacheMock.GetCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CacheMock.GetCart")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, i1)
	}
	mmGetCart.t.Fatalf("Unexpected call to CacheMock.GetCart. %v %v", ctx, i1)
	return
}

// GetCartAfterCounter returns a count of finished CacheMock.GetCart invocations
func (mmGetCart *CacheMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CacheMock.GetCart invocations
func (mmGetCart *CacheMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCacheMockGetCart) Calls() []*CacheMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CacheMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockGetCartDone() bool {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CacheMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.GetCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.GetCart")
		} else {
			m.t.Errorf("Expected call to CacheMock.GetCart with params: %#v", *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && mm_atomic.LoadUint64(&m.afterGetCartCounter) < 1 {
		m.t.Error("Expected call to CacheMock.GetCart")
	}
}

type mCacheMockGetProduct struct {
	mock               *CacheMock
	defaultExpectation *CacheMockGetProductExpectation
	expectations       []*CacheMockGetProductExpectation

	callArgs []*CacheMockGetProductParams
	mutex    sync.RWMutex
}

// CacheMockGetProductExpectation specifies expectation struct of the Cache.GetProduct
type CacheMockGetProductExpectation struct {
	mock    *CacheMock
	params  *CacheMockGetProductParams
	results *CacheMockGetProductResults
	Counter uint64
}

// CacheMockGetProductParams contains parameters of the Cache.GetProduct
type CacheMockGetProductParams struct {
	ctx context.Context
	i1  types.ID
}

// CacheMockGetProductResults contains results of the Cache.GetProduct
type CacheMockGetProductResults struct {
	pp1 *models.Product
	err error
}

// Expect sets up expected params for Cache.GetProduct
func (mmGetProduct *mCacheMockGetProduct) Expect(ctx context.Context, i1 types.ID) *mCacheMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("CacheMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &CacheMockGetProductExpectation{}
	}

	mmGetProduct.defaultExpectation.params = &CacheMockGetProductParams{ctx, i1}
	for _, e := range mmGetProduct.expectations {
		if minimock.Equal(e.params, mmGetProduct.defaultExpectation.params) {
			mmGetProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProduct.defaultExpectation.params)
		}
	}

	return mmGetProduct
}

// Inspect accepts an inspector function that has same arguments as the Cache.GetProduct
func (mmGetProduct *mCacheMockGetProduct) Inspect(f func(ctx context.Context, i1 types.ID)) *mCacheMockGetProduct {
	if mmGetProduct.mock.inspectFuncGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("Inspect function is already set for CacheMock.GetProduct")
	}

	mmGetProduct.mock.inspectFuncGetProduct = f

	return mmGetProduct
}

// Return sets up results that will be returned by Cache.GetProduct
func (mmGetProduct *mCacheMockGetProduct) Return(pp1 *models.Product, err error) *CacheMock {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("CacheMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &CacheMockGetProductExpectation{mock: mmGetProduct.mock}
	}
	mmGetProduct.defaultExpectation.results = &CacheMockGetProductResults{pp1, err}
	return mmGetProduct.mock
}

//Set uses given function f to mock the Cache.GetProduct method
func (mmGetProduct *mCacheMockGetProduct) Set(f func(ctx context.Context, i1 types.ID) (pp1 *models.Product, err error)) *CacheMock {
	if mmGetProduct.defaultExpectation != nil {
		mmGetProduct.mock.t.Fatalf("Default expectation is already set for the Cache.GetProduct method")
	}

	if len(mmGetProduct.expectations) > 0 {
		mmGetProduct.mock.t.Fatalf("Some expectations are already set for the Cache.GetProduct method")
	}

	mmGetProduct.mock.funcGetProduct = f
	return mmGetProduct.mock
}

// When sets expectation for the Cache.GetProduct which will trigger the result defined by the following
// Then helper
func (mmGetProduct *mCacheMockGetProduct) When(ctx context.Context, i1 types.ID) *CacheMockGetProductExpectation {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("CacheMock.GetProduct mock is already set by Set")
	}

	expectation := &CacheMockGetProductExpectation{
		mock:   mmGetProduct.mock,
		params: &CacheMockGetProductParams{ctx, i1},
	}
	mmGetProduct.expectations = append(mmGetProduct.expectations, expectation)
	return expectation
}

// Then sets up Cache.GetProduct return parameters for the expectation previously defined by the When method
func (e *CacheMockGetProductExpectation) Then(pp1 *models.Product, err error) *CacheMock {
	e.results = &CacheMockGetProductResults{pp1, err}
	return e.mock
}

// GetProduct implements Cache
func (mmGetProduct *CacheMock) GetProduct(ctx context.Context, i1 types.ID) (pp1 *models.Product, err error) {
	mm_atomic.AddUint64(&mmGetProduct.beforeGetProductCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProduct.afterGetProductCounter, 1)

	if mmGetProduct.inspectFuncGetProduct != nil {
		mmGetProduct.inspectFuncGetProduct(ctx, i1)
	}

	mm_params := &CacheMockGetProductParams{ctx, i1}

	// Record call args
	mmGetProduct.GetProductMock.mutex.Lock()
	mmGetProduct.GetProductMock.callArgs = append(mmGetProduct.GetProductMock.callArgs, mm_params)
	mmGetProduct.GetProductMock.mutex.Unlock()

	for _, e := range mmGetProduct.GetProductMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetProduct.GetProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProduct.GetProductMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProduct.GetProductMock.defaultExpectation.params
		mm_got := CacheMockGetProductParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProduct.t.Errorf("CacheMock.GetProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProduct.GetProductMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProduct.t.Fatal("No results are set for the CacheMock.GetProduct")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetProduct.funcGetProduct != nil {
		return mmGetProduct.funcGetProduct(ctx, i1)
	}
	mmGetProduct.t.Fatalf("Unexpected call to CacheMock.GetProduct. %v %v", ctx, i1)
	return
}

// GetProductAfterCounter returns a count of finished CacheMock.GetProduct invocations
func (mmGetProduct *CacheMock) GetProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.afterGetProductCounter)
}

// GetProductBeforeCounter returns a count of CacheMock.GetProduct invocations
func (mmGetProduct *CacheMock) GetProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.beforeGetProductCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.GetProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProduct *mCacheMockGetProduct) Calls() []*CacheMockGetProductParams {
	mmGetProduct.mutex.RLock()

	argCopy := make([]*CacheMockGetProductParams, len(mmGetProduct.callArgs))
	copy(argCopy, mmGetProduct.callArgs)

	mmGetProduct.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductDone returns true if the count of the GetProduct invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockGetProductDone() bool {
	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProduct != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProductInspect logs each unmet expectation
func (m *CacheMock) MinimockGetProductInspect() {
	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.GetProduct with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		if m.GetProductMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.GetProduct")
		} else {
			m.t.Errorf("Expected call to CacheMock.GetProduct with params: %#v", *m.GetProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProduct != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		m.t.Error("Expected call to CacheMock.GetProduct")
	}
}

type mCacheMockGetReviews struct {
	mock               *CacheMock
	defaultExpectation *CacheMockGetReviewsExpectation
	expectations       []*CacheMockGetReviewsExpectation

	callArgs []*CacheMockGetReviewsParams
	mutex    sync.RWMutex
}

// CacheMockGetReviewsExpectation specifies expectation struct of the Cache.GetReviews
type CacheMockGetReviewsExpectation struct {
	mock    *CacheMock
	params  *CacheMockGetReviewsParams
	results *CacheMockGetReviewsResults
	Counter uint64
}

// CacheMockGetReviewsParams contains parameters of the Cache.GetReviews
type CacheMockGetReviewsParams struct {
	ctx context.Context
	i1  types.ID
}

// CacheMockGetReviewsResults contains results of the Cache.GetReviews
type CacheMockGetReviewsResults struct {
	ra1 []models.Review
	err error
}

// Expect sets up expected params for Cache.GetReviews
func (mmGetReviews *mCacheMockGetReviews) Expect(ctx context.Context, i1 types.ID) *mCacheMockGetReviews {
	if mmGetReviews.mock.funcGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("CacheMock.GetReviews mock is already set by Set")
	}

	if mmGetReviews.defaultExpectation == nil {
		mmGetReviews.defaultExpectation = &CacheMockGetReviewsExpectation{}
	}

	mmGetReviews.defaultExpectation.params = &CacheMockGetReviewsParams{ctx, i1}
	for _, e := range mmGetReviews.expectations {
		if minimock.Equal(e.params, mmGetReviews.defaultExpectation.params) {
			mmGetReviews.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReviews.defaultExpectation.params)
		}
	}

	return mmGetReviews
}

// Inspect accepts an inspector function that has same arguments as the Cache.GetReviews
func (mmGetReviews *mCacheMockGetReviews) Inspect(f func(ctx context.Context, i1 types.ID)) *mCacheMockGetReviews {
	if mmGetReviews.mock.inspectFuncGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("Inspect function is already set for CacheMock.GetReviews")
	}

	mmGetReviews.mock.inspectFuncGetReviews = f

	return mmGetReviews
}

// Return sets up results that will be returned by Cache.GetReviews
func (mmGetReviews *mCacheMockGetReviews) Return(ra1 []models.Review, err error) *CacheMock {
	if mmGetReviews.mock.funcGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("CacheMock.GetReviews mock is already set by Set")
	}

	if mmGetReviews.defaultExpectation == nil {
		mmGetReviews.defaultExpectation = &CacheMockGetReviewsExpectation{mock: mmGetReviews.mock}
	}
	mmGetReviews.defaultExpectation.results = &CacheMockGetReviewsResults{ra1, err}
	return mmGetReviews.mock
}

//Set uses given function f to mock the Cache.GetReviews method
func (mmGetReviews *mCacheMockGetReviews) Set(f func(ctx context.Context, i1 types.ID) (ra1 []models.Review, err error)) *CacheMock {
	if mmGetReviews.defaultExpectation != nil {
		mmGetReviews.mock.t.Fatalf("Default expectation is already set for the Cache.GetReviews method")
	}

	if len(mmGetReviews.expectations) > 0 {
		mmGetReviews.mock.t.Fatalf("Some expectations are already set for the Cache.GetReviews method")
	}

	mmGetReviews.mock.funcGetReviews = f
	return mmGetReviews.mock
}

// When sets expectation for the Cache.GetReviews which will trigger the result defined by the following
// Then helper
func (mmGetReviews *mCacheMockGetReviews) When(ctx context.Context, i1 types.ID) *CacheMockGetReviewsExpectation {
	if mmGetReviews.mock.funcGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("CacheMock.GetReviews mock is already set by Set")
	}

	expectation := &CacheMockGetReviewsExpectation{
		mock:   mmGetReviews.mock,
		params: &CacheMockGetReviewsParams{ctx, i1},
	}
	mmGetReviews.expectations = append(mmGetReviews.expectations, expectation)
	return expectation
}

// Then sets up Cache.GetReviews return parameters for the expectation previously defined by the When method
func (e *CacheMockGetReviewsExpectation) Then(ra1 []models.Review, err error) *CacheMock {
	e.results = &CacheMockGetReviewsResults{ra1, err}
	return e.mock
}

// GetReviews implements Cache
func (mmGetReviews *CacheMock) GetReviews(ctx context.Context, i1 types.ID) (ra1 []models.Review, err error) {
	mm_atomic.AddUint64(&mmGetReviews.beforeGetReviewsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReviews.afterGetReviewsCounter, 1)

	if mmGetReviews.inspectFuncGetReviews != nil {
		mmGetReviews.inspectFuncGetReviews(ctx, i1)
	}

	mm_params := &CacheMockGetReviewsParams{ctx, i1}

	// Record call args
	mmGetReviews.GetReviewsMock.mutex.Lock()
	mmGetReviews.GetReviewsMock.callArgs = append(mmGetReviews.GetReviewsMock.callArgs, mm_params)
	mmGetReviews.GetReviewsMock.mutex.Unlock()

	for _, e := range mmGetReviews.GetReviewsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmGetReviews.GetReviewsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReviews.GetReviewsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReviews.GetReviewsMock.defaultExpectation.params
		mm_got := CacheMockGetReviewsParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReviews.t.Errorf("CacheMock.GetReviews got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReviews.GetReviewsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReviews.t.Fatal("No results are set for the CacheMock.GetReviews")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmGetReviews.funcGetReviews != nil {
		return mmGetReviews.funcGetReviews(ctx, i1)
	}
	mmGetReviews.t.Fatalf("Unexpected call to CacheMock.GetReviews. %v %v", ctx, i1)
	return
}

// GetReviewsAfterCounter returns a count of finished CacheMock.GetReviews invocations
func (mmGetReviews *CacheMock) GetReviewsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReviews.afterGetReviewsCounter)
}

// GetReviewsBeforeCounter returns a count of CacheMock.GetReviews invocations
func (mmGetReviews *CacheMock) GetReviewsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReviews.beforeGetReviewsCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.GetReviews.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReviews *mCacheMockGetReviews) Calls() []*CacheMockGetReviewsParams {
	mmGetReviews.mutex.RLock()

	argCopy := make([]*CacheMockGetReviewsParams, len(mmGetReviews.callArgs))
	copy(argCopy, mmGetReviews.callArgs)

	mmGetReviews.mutex.RUnlock()

	return argCopy
}

// MinimockGetReviewsDone returns true if the count of the GetReviews invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockGetReviewsDone() bool {
	for _, e := range m.GetReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReviewsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReviewsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReviews != nil && mm_atomic.LoadUint64(&m.afterGetReviewsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetReviewsInspect logs each unmet expectation
func (m *CacheMock) MinimockGetReviewsInspect() {
	for _, e := range m.GetReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.GetReviews with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetReviewsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetReviewsCounter) < 1 {
		if m.GetReviewsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.GetReviews")
		} else {
			m.t.Errorf("Expected call to CacheMock.GetReviews with params: %#v", *m.GetReviewsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReviews != nil && mm_atomic.LoadUint64(&m.afterGetReviewsCounter) < 1 {
		m.t.Error("Expected call to CacheMock.GetReviews")
	}
}

type mCacheMockUpsertCart struct {
	mock               *CacheMock
	defaultExpectation *CacheMockUpsertCartExpectation
	expectations       []*CacheMockUpsertCartExpectation

	callArgs []*CacheMockUpsertCartParams
	mutex    sync.RWMutex
}

// CacheMockUpsertCartExpectation specifies expectation struct of the Cache.UpsertCart
type CacheMockUpsertCartExpectation struct {
	mock    *CacheMock
	params  *CacheMockUpsertCartParams
	results *CacheMockUpsertCartResults
	Counter uint64
}

// CacheMockUpsertCartParams contains parameters of the Cache.UpsertCart
type CacheMockUpsertCartParams struct {
	ctx context.Context
	c2  models.Cart
}

// CacheMockUpsertCartResults contains results of the Cache.UpsertCart
type CacheMockUpsertCartResults struct {
	err error
}

// Expect sets up expected params for Cache.UpsertCart
func (mmUpsertCart *mCacheMockUpsertCart) Expect(ctx context.Context, c2 models.Cart) *mCacheMockUpsertCart {
	if mmUpsertCart.mock.funcUpsertCart != nil {
		mmUpsertCart.mock.t.Fatalf("CacheMock.UpsertCart mock is already set by Set")
	}

	if mmUpsertCart.defaultExpectation == nil {
		mmUpsertCart.defaultExpectation = &CacheMockUpsertCartExpectation{}
	}

	mmUpsertCart.defaultExpectation.params = &CacheMockUpsertCartParams{ctx, c2}
	for _, e := range mmUpsertCart.expectations {
		if minimock.Equal(e.params, mmUpsertCart.defaultExpectation.params) {
			mmUpsertCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertCart.defaultExpectation.params)
		}
	}

	return mmUpsertCart
}

// Inspect accepts an inspector function that has same arguments as the Cache.UpsertCart
func (mmUpsertCart *mCacheMockUpsertCart) Inspect(f func(ctx context.Context, c2 models.Cart)) *mCacheMockUpsertCart {
	if mmUpsertCart.mock.inspectFuncUpsertCart != nil {
		mmUpsertCart.mock.t.Fatalf("Inspect function is already set for CacheMock.UpsertCart")
	}

	mmUpsertCart.mock.inspectFuncUpsertCart = f

	return mmUpsertCart
}

// Return sets up results that will be returned by Cache.UpsertCart
func (mmUpsertCart *mCacheMockUpsertCart) Return(err error) *CacheMock {
	if mmUpsertCart.mock.funcUpsertCart != nil {
		mmUpsertCart.mock.t.Fatalf("CacheMock.UpsertCart mock is already set by Set")
	}

	if mmUpsertCart.defaultExpectation == nil {
		mmUpsertCart.defaultExpectation = &CacheMockUpsertCartExpectation{mock: mmUpsertCart.mock}
	}
	mmUpsertCart.defaultExpectation.results = &CacheMockUpsertCartResults{err}
	return mmUpsertCart.mock
}

//Set uses given function f to mock the Cache.UpsertCart method
func (mmUpsertCart *mCacheMockUpsertCart) Set(f func(ctx context.Context, c2 models.Cart) (err error)) *CacheMock {
	if mmUpsertCart.defaultExpectation != nil {
		mmUpsertCart.mock.t.Fatalf("Default expectation is already set for the Cache.UpsertCart method")
	}

	if len(mmUpsertCart.expectations) > 0 {
		mmUpsertCart.mock.t.Fatalf("Some expectations are already set for the Cache.UpsertCart method")
	}

	mmUpsertCart.mock.funcUpsertCart = f
	return mmUpsertCart.mock
}

// When sets expectation for the Cache.UpsertCart which will trigger the result defined by the following
// Then helper
func (mmUpsertCart *mCacheMockUpsertCart) When(ctx context.Context, c2 models.Cart) *CacheMockUpsertCartExpectation {
	if mmUpsertCart.mock.funcUpsertCart != nil {
		mmUpsertCart.mock.t.Fatalf("CacheMock.UpsertCart mock is already set by Set")
	}

	expectation := &CacheMockUpsertCartExpectation{
		mock:   mmUpsertCart.mock,
		params: &CacheMockUpsertCartParams{ctx, c2},
	}
	mmUpsertCart.expectations = append(mmUpsertCart.expectations, expectation)
	return expectation
}

// Then sets up Cache.UpsertCart return parameters for the expectation previously defined by the When method
func (e *CacheMockUpsertCartExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockUpsertCartResults{err}
	return e.mock
}

// UpsertCart implements Cache
func (mmUpsertCart *CacheMock) UpsertCart(ctx context.Context, c2 models.Cart) (err error) {
	mm_atomic.AddUint64(&mmUpsertCart.beforeUpsertCartCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertCart.afterUpsertCartCounter, 1)

	if mmUpsertCart.inspectFuncUpsertCart != nil {
		mmUpsertCart.inspectFuncUpsertCart(ctx, c2)
	}

	mm_params := &CacheMockUpsertCartParams{ctx, c2}

	// Record call args
	mmUpsertCart.UpsertCartMock.mutex.Lock()
	mmUpsertCart.UpsertCartMock.callArgs = append(mmUpsertCart.UpsertCartMock.callArgs, mm_params)
	mmUpsertCart.UpsertCartMock.mutex.Unlock()

	for _, e := range mmUpsertCart.UpsertCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertCart.UpsertCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertCart.UpsertCartMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertCart.UpsertCartMock.defaultExpectation.params
		mm_got := CacheMockUpsertCartParams{ctx, c2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertCart.t.Errorf("CacheMock.UpsertCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertCart.UpsertCartMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertCart.t.Fatal("No results are set for the CacheMock.UpsertCart")
		}
		return (*mm_results).err
	}
	if mmUpsertCart.funcUpsertCart != nil {
		return mmUpsertCart.funcUpsertCart(ctx, c2)
	}
	mmUpsertCart.t.Fatalf("Unexpected call to CacheMock.UpsertCart. %v %v", ctx, c2)
	return
}

// UpsertCartAfterCounter returns a count of finished CacheMock.UpsertCart invocations
func (mmUpsertCart *CacheMock) UpsertCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertCart.afterUpsertCartCounter)
}

// UpsertCartBeforeCounter returns a count of CacheMock.UpsertCart invocations
func (mmUpsertCart *CacheMock) UpsertCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertCart.beforeUpsertCartCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.UpsertCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertCart *mCacheMockUpsertCart) Calls() []*CacheMockUpsertCartParams {
	mmUpsertCart.mutex.RLock()

	argCopy := make([]*CacheMockUpsertCartParams, len(mmUpsertCart.callArgs))
	copy(argCopy, mmUpsertCart.callArgs)

	mmUpsertCart.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertCartDone returns true if the count of the UpsertCart invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockUpsertCartDone() bool {
	for _, e := range m.UpsertCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertCart != nil && mm_atomic.LoadUint64(&m.afterUpsertCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertCartInspect logs each unmet expectation
func (m *CacheMock) MinimockUpsertCartInspect() {
	for _, e := range m.UpsertCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.UpsertCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertCartCounter) < 1 {
		if m.UpsertCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.UpsertCart")
		} else {
			m.t.Errorf("Expected call to CacheMock.UpsertCart with params: %#v", *m.UpsertCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertCart != nil && mm_atomic.LoadUint64(&m.afterUpsertCartCounter) < 1 {
		m.t.Error("Expected call to CacheMock.UpsertCart")
	}
}

type mCacheMockUpsertProduct struct {
	mock               *CacheMock
	defaultExpectation *CacheMockUpsertProductExpectation
	expectations       []*CacheMockUpsertProductExpectation

	callArgs []*CacheMockUpsertProductParams
	mutex    sync.RWMutex
}

// CacheMockUpsertProductExpectation specifies expectation struct of the Cache.UpsertProduct
type CacheMockUpsertProductExpectation struct {
	mock    *CacheMock
	params  *CacheMockUpsertProductParams
	results *CacheMockUpsertProductResults
	Counter uint64
}

// CacheMockUpsertProductParams contains parameters of the Cache.UpsertProduct
type CacheMockUpsertProductParams struct {
	ctx context.Context
	p1  models.Product
}

// CacheMockUpsertProductResults contains results of the Cache.UpsertProduct
type CacheMockUpsertProductResults struct {
	err error
}

// Expect sets up expected params for Cache.UpsertProduct
func (mmUpsertProduct *mCacheMockUpsertProduct) Expect(ctx context.Context, p1 models.Product) *mCacheMockUpsertProduct {
	if mmUpsertProduct.mock.funcUpsertProduct != nil {
		mmUpsertProduct.mock.t.Fatalf("CacheMock.UpsertProduct mock is already set by Set")
	}

	if mmUpsertProduct.defaultExpectation == nil {
		mmUpsertProduct.defaultExpectation = &CacheMockUpsertProductExpectation{}
	}

	mmUpsertProduct.defaultExpectation.params = &CacheMockUpsertProductParams{ctx, p1}
	for _, e := range mmUpsertProduct.expectations {
		if minimock.Equal(e.params, mmUpsertProduct.defaultExpectation.params) {
			mmUpsertProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertProduct.defaultExpectation.params)
		}
	}

	return mmUpsertProduct
}

// Inspect accepts an inspector function that has same arguments as the Cache.UpsertProduct
func (mmUpsertProduct *mCacheMockUpsertProduct) Inspect(f func(ctx context.Context, p1 models.Product)) *mCacheMockUpsertProduct {
	if mmUpsertProduct.mock.inspectFuncUpsertProduct != nil {
		mmUpsertProduct.mock.t.Fatalf("Inspect function is already set for CacheMock.UpsertProduct")
	}

	mmUpsertProduct.mock.inspectFuncUpsertProduct = f

	return mmUpsertProduct
}

// Return sets up results that will be returned by Cache.UpsertProduct
func (mmUpsertProduct *mCacheMockUpsertProduct) Return(err error) *CacheMock {
	if mmUpsertProduct.mock.funcUpsertProduct != nil {
		mmUpsertProduct.mock.t.Fatalf("CacheMock.UpsertProduct mock is already set by Set")
	}

	if mmUpsertProduct.defaultExpectation == nil {
		mmUpsertProduct.defaultExpectation = &CacheMockUpsertProductExpectation{mock: mmUpsertProduct.mock}
	}
	mmUpsertProduct.defaultExpectation.results = &CacheMockUpsertProductResults{err}
	return mmUpsertProduct.mock
}

//Set uses given function f to mock the Cache.UpsertProduct method
func (mmUpsertProduct *mCacheMockUpsertProduct) Set(f func(ctx context.Context, p1 models.Product) (err error)) *CacheMock {
	if mmUpsertProduct.defaultExpectation != nil {
		mmUpsertProduct.mock.t.Fatalf("Default expectation is already set for the Cache.UpsertProduct method")
	}

	if len(mmUpsertProduct.expectations) > 0 {
		mmUpsertProduct.mock.t.Fatalf("Some expectations are already set for the Cache.UpsertProduct method")
	}

	mmUpsertProduct.mock.funcUpsertProduct = f
	return mmUpsertProduct.mock
}

// When sets expectation for the Cache.UpsertProduct which will trigger the result defined by the following
// Then helper
func (mmUpsertProduct *mCacheMockUpsertProduct) When(ctx context.Context, p1 models.Product) *CacheMockUpsertProductExpectation {
	if mmUpsertProduct.mock.funcUpsertProduct != nil {
		mmUpsertProduct.mock.t.Fatalf("CacheMock.UpsertProduct mock is already set by Set")
	}

	expectation := &CacheMockUpsertProductExpectation{
		mock:   mmUpsertProduct.mock,
		params: &CacheMockUpsertProductParams{ctx, p1},
	}
	mmUpsertProduct.expectations = append(mmUpsertProduct.expectations, expectation)
	return expectation
}

// Then sets up Cache.UpsertProduct return parameters for the expectation previously defined by the When method
func (e *CacheMockUpsertProductExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockUpsertProductResults{err}
	return e.mock
}

// UpsertProduct implements Cache
func (mmUpsertProduct *CacheMock) UpsertProduct(ctx context.Context, p1 models.Product) (err error) {
	mm_atomic.AddUint64(&mmUpsertProduct.beforeUpsertProductCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertProduct.afterUpsertProductCounter, 1)

	if mmUpsertProduct.inspectFuncUpsertProduct != nil {
		mmUpsertProduct.inspectFuncUpsertProduct(ctx, p1)
	}

	mm_params := &CacheMockUpsertProductParams{ctx, p1}

	// Record call args
	mmUpsertProduct.UpsertProductMock.mutex.Lock()
	mmUpsertProduct.UpsertProductMock.callArgs = append(mmUpsertProduct.UpsertProductMock.callArgs, mm_params)
	mmUpsertProduct.UpsertProductMock.mutex.Unlock()

	for _, e := range mmUpsertProduct.UpsertProductMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertProduct.UpsertProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertProduct.UpsertProductMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertProduct.UpsertProductMock.defaultExpectation.params
		mm_got := CacheMockUpsertProductParams{ctx, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertProduct.t.Errorf("CacheMock.UpsertProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertProduct.UpsertProductMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertProduct.t.Fatal("No results are set for the CacheMock.UpsertProduct")
		}
		return (*mm_results).err
	}
	if mmUpsertProduct.funcUpsertProduct != nil {
		return mmUpsertProduct.funcUpsertProduct(ctx, p1)
	}
	mmUpsertProduct.t.Fatalf("Unexpected call to CacheMock.UpsertProduct. %v %v", ctx, p1)
	return
}

// UpsertProductAfterCounter returns a count of finished CacheMock.UpsertProduct invocations
func (mmUpsertProduct *CacheMock) UpsertProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertProduct.afterUpsertProductCounter)
}

// UpsertProductBeforeCounter returns a count of CacheMock.UpsertProduct invocations
func (mmUpsertProduct *CacheMock) UpsertProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertProduct.beforeUpsertProductCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.UpsertProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertProduct *mCacheMockUpsertProduct) Calls() []*CacheMockUpsertProductParams {
	mmUpsertProduct.mutex.RLock()

	argCopy := make([]*CacheMockUpsertProductParams, len(mmUpsertProduct.callArgs))
	copy(argCopy, mmUpsertProduct.callArgs)

	mmUpsertProduct.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertProductDone returns true if the count of the UpsertProduct invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockUpsertProductDone() bool {
	for _, e := range m.UpsertProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertProductCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertProduct != nil && mm_atomic.LoadUint64(&m.afterUpsertProductCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertProductInspect logs each unmet expectation
func (m *CacheMock) MinimockUpsertProductInspect() {
	for _, e := range m.UpsertProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.UpsertProduct with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertProductCounter) < 1 {
		if m.UpsertProductMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.UpsertProduct")
		} else {
			m.t.Errorf("Expected call to CacheMock.UpsertProduct with params: %#v", *m.UpsertProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertProduct != nil && mm_atomic.LoadUint64(&m.afterUpsertProductCounter) < 1 {
		m.t.Error("Expected call to CacheMock.UpsertProduct")
	}
}

type mCacheMockUpsertReviews struct {
	mock               *CacheMock
	defaultExpectation *CacheMockUpsertReviewsExpectation
	expectations       []*CacheMockUpsertReviewsExpectation

	callArgs []*CacheMockUpsertReviewsParams
	mutex    sync.RWMutex
}

// CacheMockUpsertReviewsExpectation specifies expectation struct of the Cache.UpsertReviews
type CacheMockUpsertReviewsExpectation struct {
	mock    *CacheMock
	params  *CacheMockUpsertReviewsParams
	results *CacheMockUpsertReviewsResults
	Counter uint64
}

// CacheMockUpsertReviewsParams contains parameters of the Cache.UpsertReviews
type CacheMockUpsertReviewsParams struct {
	ctx context.Context
	i1  types.ID
	ra1 []models.Review
}

// CacheMockUpsertReviewsResults contains results of the Cache.UpsertReviews
type CacheMockUpsertReviewsResults struct {
	err error
}

// Expect sets up expected params for Cache.UpsertReviews
func (mmUpsertReviews *mCacheMockUpsertReviews) Expect(ctx context.Context, i1 types.ID, ra1 []models.Review) *mCacheMockUpsertReviews {
	if mmUpsertReviews.mock.funcUpsertReviews != nil {
		mmUpsertReviews.mock.t.Fatalf("CacheMock.UpsertReviews mock is already set by Set")
	}

	if mmUpsertReviews.defaultExpectation == nil {
		mmUpsertReviews.defaultExpectation = &CacheMockUpsertReviewsExpectation{}
	}

	mmUpsertReviews.defaultExpectation.params = &CacheMockUpsertReviewsParams{ctx, i1, ra1}
	for _, e := range mmUpsertReviews.expectations {
		if minimock.Equal(e.params, mmUpsertReviews.defaultExpectation.params) {
			mmUpsertReviews.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertReviews.defaultExpectation.params)
		}
	}

	return mmUpsertReviews
}

// Inspect accepts an inspector function that has same arguments as the Cache.UpsertReviews
func (mmUpsertReviews *mCacheMockUpsertReviews) Inspect(f func(ctx context.Context, i1 types.ID, ra1 []models.Review)) *mCacheMockUpsertReviews {
	if mmUpsertReviews.mock.inspectFuncUpsertReviews != nil {
		mmUpsertReviews.mock.t.Fatalf("Inspect function is already set for CacheMock.UpsertReviews")
	}

	mmUpsertReviews.mock.inspectFuncUpsertReviews = f

	return mmUpsertReviews
}

// Return sets up results that will be returned by Cache.UpsertReviews
func (mmUpsertReviews *mCacheMockUpsertReviews) Return(err error) *CacheMock {
	if mmUpsertReviews.mock.funcUpsertReviews != nil {
		mmUpsertReviews.mock.t.Fatalf("CacheMock.UpsertReviews mock is already set by Set")
	}

	if mmUpsertReviews.defaultExpectation == nil {
		mmUpsertReviews.defaultExpectation = &CacheMockUpsertReviewsExpectation{mock: mmUpsertReviews.mock}
	}
	mmUpsertReviews.defaultExpectation.results = &CacheMockUpsertReviewsResults{err}
	return mmUpsertReviews.mock
}

//Set uses given function f to mock the Cache.UpsertReviews method
func (mmUpsertReviews *mCacheMockUpsertReviews) Set(f func(ctx context.Context, i1 types.ID, ra1 []models.Review) (err error)) *CacheMock {
	if mmUpsertReviews.defaultExpectation != nil {
		mmUpsertReviews.mock.t.Fatalf("Default expectation is already set for the Cache.UpsertReviews method")
	}

	if len(mmUpsertReviews.expectations) > 0 {
		mmUpsertReviews.mock.t.Fatalf("Some expectations are already set for the Cache.UpsertReviews method")
	}

	mmUpsertReviews.mock.funcUpsertReviews = f
	return mmUpsertReviews.mock
}

// When sets expectation for the Cache.UpsertReviews which will trigger the result defined by the following
// Then helper
func (mmUpsertReviews *mCacheMockUpsertReviews) When(ctx context.Context, i1 types.ID, ra1 []models.Review) *CacheMockUpsertReviewsExpectation {
	if mmUpsertReviews.mock.funcUpsertReviews != nil {
		mmUpsertReviews.mock.t.Fatalf("CacheMock.UpsertReviews mock is already set by Set")
	}

	expectation := &CacheMockUpsertReviewsExpectation{
		mock:   mmUpsertReviews.mock,
		params: &CacheMockUpsertReviewsParams{ctx, i1, ra1},
	}
	mmUpsertReviews.expectations = append(mmUpsertReviews.expectations, expectation)
	return expectation
}

// Then sets up Cache.UpsertReviews return parameters for the expectation previously defined by the When method
func (e *CacheMockUpsertReviewsExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockUpsertReviewsResults{err}
	return e.mock
}

// UpsertReviews implements Cache
func (mmUpsertReviews *CacheMock) UpsertReviews(ctx context.Context, i1 types.ID, ra1 []models.Review) (err error) {
	mm_atomic.AddUint64(&mmUpsertReviews.beforeUpsertReviewsCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertReviews.afterUpsertReviewsCounter, 1)

	if mmUpsertReviews.inspectFuncUpsertReviews != nil {
		mmUpsertReviews.inspectFuncUpsertReviews(ctx, i1, ra1)
	}

	mm_params := &CacheMockUpsertReviewsParams{ctx, i1, ra1}

	// Record call args
	mmUpsertReviews.UpsertReviewsMock.mutex.Lock()
	mmUpsertReviews.UpsertReviewsMock.callArgs = append(mmUpsertReviews.UpsertReviewsMock.callArgs, mm_params)
	mmUpsertReviews.UpsertReviewsMock.mutex.Unlock()

	for _, e := range mmUpsertReviews.UpsertReviewsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpsertReviews.UpsertReviewsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertReviews.UpsertReviewsMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertReviews.UpsertReviewsMock.defaultExpectation.params
		mm_got := CacheMockUpsertReviewsParams{ctx, i1, ra1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertReviews.t.Errorf("CacheMock.UpsertReviews got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertReviews.UpsertReviewsMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertReviews.t.Fatal("No results are set for the CacheMock.UpsertReviews")
		}
		return (*mm_results).err
	}
	if mmUpsertReviews.funcUpsertReviews != nil {
		return mmUpsertReviews.funcUpsertReviews(ctx, i1, ra1)
	}
	mmUpsertReviews.t.Fatalf("Unexpected call to CacheMock.UpsertReviews. %v %v %v", ctx, i1, ra1)
	return
}

// UpsertReviewsAfterCounter returns a count of finished CacheMock.UpsertReviews invocations
func (mmUpsertReviews *CacheMock) UpsertReviewsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertReviews.afterUpsertReviewsCounter)
}

// UpsertReviewsBeforeCounter returns a count of CacheMock.UpsertReviews invocations
func (mmUpsertReviews *CacheMock) UpsertReviewsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertReviews.beforeUpsertReviewsCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.UpsertReviews.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertReviews *mCacheMockUpsertReviews) Calls() []*CacheMockUpsertReviewsParams {
	mmUpsertReviews.mutex.RLock()

	argCopy := make([]*CacheMockUpsertReviewsParams, len(mmUpsertReviews.callArgs))
	copy(argCopy, mmUpsertReviews.callArgs)

	mmUpsertReviews.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertReviewsDone returns true if the count of the UpsertReviews invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockUpsertReviewsDone() bool {
	for _, e := range m.UpsertReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertReviewsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertReviewsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertReviews != nil && mm_atomic.LoadUint64(&m.afterUpsertReviewsCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertReviewsInspect logs each unmet expectation
func (m *CacheMock) MinimockUpsertReviewsInspect() {
	for _, e := range m.UpsertReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.UpsertReviews with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertReviewsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertReviewsCounter) < 1 {
		if m.UpsertReviewsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.UpsertReviews")
		} else {
			m.t.Errorf("Expected call to CacheMock.UpsertReviews with params: %#v", *m.UpsertReviewsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertReviews != nil && mm_atomic.LoadUint64(&m.afterUpsertReviewsCounter) < 1 {
		m.t.Error("Expected call to CacheMock.UpsertReviews")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAppendReviewInspect()

		m.MinimockGetCartInspect()

		m.MinimockGetProductInspect()

		m.MinimockGetReviewsInspect()

		m.MinimockUpsertCartInspect()

		m.MinimockUpsertProductInspect()

		m.MinimockUpsertReviewsInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAppendReviewDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockGetProductDone() &&
		m.MinimockGetReviewsDone() &&
		m.MinimockUpsertCartDone() &&
		m.MinimockUpsertProductDone() &&
		m.MinimockUpsertReviewsDone()
}
